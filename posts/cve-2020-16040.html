
<html>
<head>
<meta name="Description" content="CVE-2020-16040 Analysis and Exploitation - A Chrome V8 Engine Browser Exploit (Simplified Lowering)">
<link rel="stylesheet" href="../Resources/css/hack.css">
<link rel="stylesheet" href="../Resources/css/themes/dark.css">
<link rel="stylesheet" href="../Resources/highlight/styles/custom.min.css">
<script src="../Resources/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<title>CVE-2020-16040 Analysis and Exploitation</title>
</head>
<script>
  document.addEventListener('DOMContentLoaded', function() {
    var elements = document.querySelectorAll('body *');
    elements.forEach(function(element) {
      element.innerHTML = element.innerHTML.replace(/`([^`]+)`/g, '<span class="marked-text">$1</span>');
    });
  });
</script>

<p>
<center><img src="../images/ret_logo.png" width="80"></center><br>
<center>((((&lambda;f.(&lambda;x.(fx)))(&lambda;y.y))(&lambda;z.z)))</center>
<p>
<center><< <a href="../index.html">home</a> >></center>
<body class="hack dark">
  <div class="main container">
<h1>0x02a: CVE-2020-16040 Analysis and Exploitation</h1>
<pre class="hack dark"> 
 _      ___            _____          _____
| |__  / _ \ _ __ ___ |___ /  ___ _ _|___ /_      __
|  _ \| | | |  _   _ \  |_ \ / __|  __||_ \ \ /\ / /
| | | | |_| | | | | | |___) | (__| |  ___) \ V  V /
|_| |_|\___/|_| |_| |_|____/ \___|_| |____/ \_/\_/

+-----[ fourteen karat gold slum computer wizard ]-----+

___________________________________________________________________</pre>
 <script>
  document.addEventListener('DOMContentLoaded', function() {
    var elements = document.querySelectorAll('body *');
    elements.forEach(function(element) {
      element.innerHTML = element.innerHTML.replace(/`([^`]+)`/g, '<span class="marked-text" style="background-color: #f8f8f8; color: #333; padding: 2px 4px; border-radius: 4px; font-family: monospace;">$1</span>');
    });
  });
</script>
   
<h2><font color="white">[ OVERVIEW ]</font></h2>

<p>Looking at the published CVE ID associated with this particular vulnerability (<code>CVE-2020-16040</code>), a <a href="https://crbug.com/1150649">chrome bug tracker</a> reference is provided that contains additional information in in pertinence to the vulnerability specifics. We can attain further details in the following <a href="https://chromium-review.googlesource.com/c/v8/v8/+/2557498">commit</a> including the patch diff, patch commit and the disclosed regression test (<code>regress-1150649.js</code>), which will be looked at later.</p>
<pre style="background-color: #100E15; border: none !important;">
<code class="language-plaintext">
[compiler] Fix a bug in SimplifiedLowering

SL's VisitSpeculativeIntegerAdditiveOp was setting Signed32 as
restriction type even when relying on a Word32 truncation in
order to skip the overflow check. This is not sound.
</code>
</pre>
<p>The vulnerable version of V8 in question is associated with commit <code>2781d585038b97ed375f2ec06651dc9e5e04f916</code>.</p>

<p>The patch diff can be seen below:</p>
<pre style="background-color: #100E15; border: none !important;">
<code>
diff --git a/src/compiler/simplified-lowering.cc b/src/compiler/simplified-lowering.cc
index a1f10f98fe5..ef56d56e447 100644
--- a/src/compiler/simplified-lowering.cc
+++ b/src/compiler/simplified-lowering.cc
@@ -1409,7 +1409,6 @@ class RepresentationSelector {
                 IsSomePositiveOrderedNumber(input1_type)
             ? CheckForMinusZeroMode::kDontCheckForMinusZero
             : CheckForMinusZeroMode::kCheckForMinusZero;
-
     NodeProperties::ChangeOp(node, simplified()->CheckedInt32Mul(mz_mode));
   }
 
@@ -1453,6 +1452,13 @@ class RepresentationSelector {
 
     Type left_feedback_type = TypeOf(node->InputAt(0));
     Type right_feedback_type = TypeOf(node->InputAt(1));
+
+    // Using Signed32 as restriction type amounts to promising there won't be
+    // signed overflow. This is incompatible with relying on a Word32
+    // truncation in order to skip the overflow check.
+    Type const restriction =
+        truncation.IsUsedAsWord32() ? Type::Any() : Type::Signed32();
+
     // Handle the case when no int32 checks on inputs are necessary (but
     // an overflow check is needed on the output). Note that we do not
     // have to do any check if at most one side can be minus zero. For
@@ -1466,7 +1472,7 @@ class RepresentationSelector {
         right_upper.Is(Type::Signed32OrMinusZero()) &&
         (left_upper.Is(Type::Signed32()) || right_upper.Is(Type::Signed32()))) {
       VisitBinop<T>(node, UseInfo::TruncatingWord32(),
-                    MachineRepresentation::kWord32, Type::Signed32());
+                    MachineRepresentation::kWord32, restriction);
     } else {
       // If the output's truncation is identify-zeros, we can pass it
       // along. Moreover, if the operation is addition and we know the
@@ -1486,8 +1492,9 @@ class RepresentationSelector {
       UseInfo right_use = CheckedUseInfoAsWord32FromHint(hint, FeedbackSource(),
                                                          kIdentifyZeros);
       VisitBinop<T>(node, left_use, right_use, MachineRepresentation::kWord32,
-                    Type::Signed32());
+                    restriction);
     }
+
     if (lower<T>()) {
       if (truncation.IsUsedAsWord32() ||
           !CanOverflowSigned32(node->op(), left_feedback_type,
diff --git a/test/mjsunit/compiler/regress-1150649.js b/test/mjsunit/compiler/regress-1150649.js
new file mode 100644
index 00000000000..a193481a3a2
--- /dev/null
+++ b/test/mjsunit/compiler/regress-1150649.js
@@ -0,0 +1,24 @@
+// Copyright 2020 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// Flags: --allow-natives-syntax
+
+function foo(a) {
+  var y = 0x7fffffff;  // 2^31 - 1
+
+  // Widen the static type of y (this condition never holds).
+  if (a == NaN) y = NaN;
+
+  // The next condition holds only in the warmup run. It leads to Smi
+  // (SignedSmall) feedback being collected for the addition below.
+  if (a) y = -1;
+
+  const z = (y + 1)|0;
+  return z < 0;
+}
+
+%PrepareFunctionForOptimization(foo);
+assertFalse(foo(true));
+%OptimizeFunctionOnNextCall(foo);
+assertTrue(foo(false));
</code>
</pre>
<h2><font color="white">[ SKIPPED OVERFLOW CHECK ]</font></h2>
<pre style="background-color: #100E15; border: none !important;">
<code>
bool CanOverflowSigned32(const Operator* op, Type left, Type right,
                         Zone* type_zone) {
  left = Type::Intersect(left, Type::Signed32(), type_zone);
  right = Type::Intersect(right, Type::Signed32(), type_zone);
  if (left.IsNone() || right.IsNone()) return false;
  switch (op->opcode()) {
    case IrOpcode::kSpeculativeSafeIntegerAdd:
      return (left.Max() + right.Max() > kMaxInt) ||
             (left.Min() + right.Min() < kMinInt);
    case IrOpcode::kSpeculativeSafeIntegerSubtract:
      return (left.Max() - right.Min() > kMaxInt) ||
             (left.Min() - right.Max() < kMinInt);
    default:
      UNREACHABLE();
  }
  return true;
}
</code>
</pre>
<p></p>
<center><footer><< <a href="https://github.com/ret2eax">github</a> : <a href=mailto:homecrew@riseup.net>homecrew@riseup.net</a> : <a href="https://keys.openpgp.org/search?q=D3E19869F7AF832F">pgp</a> >></footer></center>
<p>
<!-- Cloudflare Web Analytics --><script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "de308c7bac84443286fa4c969da28bb7"}'></script><!-- End Cloudflare Web Analytics -->
</body>
</html>
